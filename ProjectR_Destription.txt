** 플랫폼 : Roblox
** 프로그래밍 언어 : Lua
** 코드라인 : 14000라인
** 개발 기간 : 1달

<Project R with Roblox Studio>


* System Architecture
	
	- 여러가지 경로의 리소스를 쉽게 받아올 수 있도록 Facade(CommonModuleFacade, ClientModuleFacade, ServerModuleFacade, GuiFacade) 추가
	
	- 전체적인 게임 상태와 플레이어를 관리하는 ServerGlobalStorage, ClientGlobalStorage 정의 // 멀티스레드 기능(Parallel)을 사용할 경우 동기화에 주의해야한다.
	
		- 서버는 각 ServerGlobalStorage에 플레이어의 모든 정보를 가지고 있음, 반대로 클라이언트는 본인 정보만 들고 있고, 나머지 정보는 월드에서 리플리케이션된 정보를 받아서 갱신
		- 플레이어의 정보는 EquipSlot(도구 장착 정보), Actions(전투 관련(스킬 쿨타임, 킬 카운트 등)), Statistic(현재 플레이어 스탯 통계), Inventory(인벤토리 정보), QuickSlot(클라이언트에만 존재하는 퀵슬롯 정보)로 존재
		- 기본적으로 모든 패킷처리(RemoveEvent 등)은 ServerGlobalStorage, ClientGlobalStorage에서 수행, 클라이언트 측에서는 ClientGlobalStorage에서 GuiController를 호출하여 Gui를 갱신
	
	- Lua에는 기본적으로 클래스를 지원하지 않기 때문에 table과 metatable, __index, __newindex을 활용하여 상속이 가능하도록 만들어서 사용
	- Server, Client 에서는 CommonConstant, CommonEnum(공통 코드)를 상속받은 ServerConstant, ClientConstant 과 ServerEnum, ClientEnum을 사용
	- 기본적으로 패킷은 RemoteEvent를 사용. 특히 문자열 같은 경우에는 Key 종류의 데이터를 보내서 클라이언트에서 출력하여 대역폭을 줄임(간단한 값은 그냥 값 자체를 리플리케이션)
	- 서버에서 모든 정보를 통보하지 않는 대신(GameData 등) 클라이언트 변조 시, 치팅이 발생하지 않도록 정확한 검증 코드를 작성
	
	
	
* GameData

	- GameData들을 모두 가지고 있는 GameDataManager 정의, 서버, 클라이언트 모두 존재하지만 서버가 더 많은 정보를 들고 있음
	- 기본적으로 GameData에 __index, __newindex를 활용하여 불변성을 부여(외부에서 변경할 수 없음)
	- GameData 검증, 추가 로드 과정 설계
		1. LoadAdditionalData : 모든 GameData가 로드된 상황에서 추가 데이터를 로드할때 사용한다. 주로 다른 게임데이터와 연결된 ToolGameData에서 재정의하여 사용한다.
		2. ValidateData : 현재 위치한 GameData의 각 데이터를 검증하는 곳이다.
		3. ValidateDataFinally : 모든 GameData가 로드된 상황에서 전체적으로 데이터를 검증하는 곳이다.
		
	- GameData 없는 속성에 접근하려고 할 때 Assert 추가
	- DropGameData 추가, 공용 데이터인 WorldInteractorGameData의 DropGameDataKey값을 가지고 서버에서 검증, 이후 서버의 WorldInteractorGameData에서만 DropGameData 추가 로드
	- ToolGameData 추가(무기, 방어구, 각 능력치, 바인딩된 스킬 등)
	- WorldInteractorGameData 추가(ItemBox의 경우 드롭키(아이템이 바인딩되어 있음), Hp 등)
	- SkillGameData 추가(쿨다운, 스킬 계수, 스킬 처리 타입(한번만 처리할지 여러번 처리할지 결정) 등)
	- CharacterGameData 추가(기본 캐릭터 스탯)



* Object, Object System

	- ObjectBase - 기본적인 기능을 지원하도록 설계(Object의 Root객체, GameData, Key 등을 쉽게 받아올 수 있는 구조)
	- ObjectSystemBase - 월드에서 여러 종류의 객체(Tool, WorldInteractor, Npc)들을 관리하는 클래스
						 Register, Unregister, Create, Destroy 기능 수행 / 각 자식 클래스에서 오버라이딩할 수 있는 PostCreate와 같은 함수 제공
						 객체가 삭제 될 때 파츠가 분리되면서 소멸하는 기능 구현(객체에 관절이 존재하는 구조로 객체를 설계하였음, 소멸시킬 때 관절을 끊어서 소멸)
						 각 객체와 관련있는 스크립트도 다 이곳에서 관리한다. 그 이유는 다음과 같다.
							1. 각 객체마다 스크립트를 붙이면 클라이언트로 내용이 리플리케이션된다.(소스를 본다고 해도 사용할 수는 없지만, 서버 코드를 노출시키지 않을 수 있음)
							2. 각 객체 스트립트에 대해 공통 기능에 대한 처리를 편하게 해줄 수 있다.
							3. 삭제시점, 생성시점에 따라서 유연하게 코드를 작성할 수 있다.
	
	- 각 실제 리소스(Tool, WorldInteractor, Npc)와 각 GameData를 연결 시키기 위한 매핑 테이블 정의, 검증 코드 추가
	- [GUI] ObjectTooltipGui(빌보드) 추가, 마우스에 타겟팅되는 Tool, WorldInteractor, Npc의 정보를 띄워준다.
	- ObjectTooltipGui(빌보드)이 가리키는 대상을 Pickup을 서버에 요청할 수 있는 기능 제공(현재는 F키를 통해 요청하고 있음)
	
	- WorldInteractor - ItemBox 타입 추가, 각 WorldInteractor에 내부 이펙트 추가
	- WorldInteractor - ItemBox의 남은 Hp에 따라 파츠가 분리되도록 설정
	- WorldInteractor - ItemBox가 소멸할 때 WorldInteractorGameData(Common)의 DropGameDataKey(Server Only)에 따라 적절한 아이템을 드롭	
	
	- Tool - 월드 뿐아니라 캐릭터 인벤토리에 Tool을 지급하는 기능 추가
	- Tool - Armor, Weapon 타입 추가, 각 타입별로 장착되는 EquipSlot을 바인딩 / 장착, 장착해제 시 적절하게 Statistic 갱신
	- Tool - 방어구 장착 시 메시 데이터 본에 붙여서 본과 같이 시뮬레이션 될 수 있도록 Tool 내부의 계층 구조 설계(어떤 본에 붙여서 시뮬레이션 할지, 위치는 어디인지 등의 정보가 포함)



* Slot(Inventory, EquipSlot, QuickSlot)

	- Inventory를 Roblox의 Backpack 연결하여 사용, 이를 기반으로 서버, 클라이언트 정보 갱신, 동기화
	- [GUI] GuiInventory 부모 객체에 따라 크기 조절, 상수 값에 따라 슬롯 레이아웃 조절할 수 있도록 구현(슬롯 간격, 슬롯 개수 등)
	
	- EquipSlots 서버, 클라이언트 정보 갱신, 동기화
	- [GUI] GuiEquipSlots 부모 객체에 따라 크기 조절, 상수 값에 따라 슬롯 레이아웃 조절할 수 있도록 구현(슬롯 간격, 슬롯 개수 등)

	- 각 슬롯을 클릭했을 때 팝업되는 Tooltip에서 서버로 여러 요청을 보낼 수 있도록 각 버튼에 기능 바인딩(장착, 장착해제, 선택(손에 들기))
	- [GUI] Tooltip에서 해당 Tool의 ToolGameData기반 여러 정보를 출력
	- [GUI] Tooltip에서 슬롯과 Tool 종류에 따라 다양한 레이아웃의 버튼이 나올 수 있도록 구현

	- QuickSlots(ClientGlobalStorage에만 존재)에서 등록, 해제, 퀵슬롯간 스왑 기능 제공


	- [GUI] GuiInventory, GuiEquipSlots 을 단축키로 열고 닫을 수 있도록 키 바인딩 / Gui 애니메이션 적용
	- [GUI] Inventory, EquipSlot 닫힐 때, Tooltip도 닫히도록 구현
	


* Resource(Sound, Effect, Animation)


	- 각 SoundTemplate, EffectTemplate, AnimationTemplate을 파일을 통해 쉽게 데이터를 검증하면서 로드하고 사용할 수 있도록 기능을 제공하고 있음

	- [Sound] 서버에 BGM을 관리할 수 있는 BGMController 추가, FadeIn FadeOut 기능 추가
	- [Map] DesertMap 추가
	- [Effect] 각 스킬 이펙트 추가
	- [Sound] 각 스킬 사운드 추가, BGM 추가



* Character

	- Move, Jump 스탯 메모리 상에 존재하는 것을 실제 캐릭터에 적용
	- 캐릭터가 제거될 때, 생성될 때, 플레이어가 추가될 때, 삭제될 때 각 이벤트 바인딩
	
	- [GUI] KillCount 출력, 리스폰시 GUI 유지되도록 변경
	- [GUI] 사망시 공격한 플레이어 이름 출력
	- [GUI] 캐릭터 Hp와 Hp바 연동, 남은 Hp에 따라 색 변경



* Skill, Skill System
	
	- 스킬을 시뮬레이션할 수 있는 SkillSequence 설계
	
		- SkillSequence : 여러 개의 캐릭터 애니메이션, 스킬 투사체 등의 모든 시뮬레이션 데이터를 담고 있다.
		- SkillSequencePlayer : SkillSequence 데이터를 기반으로 실시간으로 시뮬레이션하는 기능을 담고 있다.
			
			- SkillSequenceAnimationTrack : 캐릭터 애니메이션과, 특정 애니메이션 시점에 바인딩된 SkillCollisionSequence들을 담고 있다.
			- SkillSequenceAnimationTrackPlayer : SkillSequenceAnimationTrack 데이터를 기반으로 실시간으로 시뮬레이션하는 기능을 담고 있다.
			
				- SkillCollisionSequence : 스킬 투사체의 정보와(사운드(OnHit, OnCreate, OnDestroy 등), 이펙트 등) 각 트랙의 시뮬레이션 데이터들을 담고 있다.(위치, 상대적인 방향, 속도, 크기 처리 방식, 충돌 여부 등)
				- SkillCollisionSequencePlayer : SkillCollisionSequence 데이터를 기반으로 실시간으로 시뮬레이션하는 기능을 담고 있다.
					- SkillCollisionSequenceTrack : 스킬 투사체의 여러 정보를 담고 있다.
					
	- 스킬 콜리전 업데이트 애니메이션 시작 시간 기준 플레이어 위치가 아닌, 콜리전 생성 시점의 플레이어 위치로 계산
	- 스킬 재사용시간 클라이언트측에서 활성화된 Tool 기준으로 계산할 수 있도록 수정(서버측에서 재검증으로 치팅 방지)
	- 충돌 처리 성능 최적화(충돌중인 객체 중에 하나만 처리하고 더 검사하지 않도록 수정)
	- Touched 이벤트 대신 TouchingParts 함수를 통해서 충돌 처리하도록 수정(이벤트가 적절하게 트리거 되지 않음)
	- SkillCollision이 Collision을 선택적으로 처리할 수있도록, CollisionGroup을 체계적으로 관리하고 충돌 가능 여부를 체크할 수 있도록 구현
	- SkillCollision을 시뮬레이션할 때 일단 코루틴으로 처리(추후 멀티스레드에 대한 기능이 확실히 나오면, 활용해 볼 예정)
	- 기본 스킬 모든 무기종류의 Tool에 바인딩
	
	
	- 스킬 종류 추가 : BaseAttack, PowerStrike, StormBlade, FlameBlade, LightningVortex, AuraBlade // 다양한 시퀀스와 특징을 가짐
	- SkillFactor추가, 이 값을 대미지에 곱하여 최종 대미지를 계산하고 있음
	- 데미지 계산 공식 추가, 이를 재사용하기 위한 공통 스크립트 정의(DamageCalculator)
	
	- [GUI] GuiSkillSlots를 장착한 Tool을 기준으로 원형으로 구성(극좌표 활용)
	- [GUI] 스킬 재사용시간 텍스트 추가
	
	
	
* ETC
	
	- Debug 코드 추가 - Assert, Log (콜스택 출력 O) / Print(콜스택 출력 X)
	- 깊은 복사, 얕은 복사, 상속, 불변성 등의 공통적인 기능을 제공하는 코드 작성
	- 컨테이너 TArray, TList 추가(보통 슬롯 코드를 구현하기 위해 사용)
	- ObjectUtility 종류의 코드를 통해 해당 리소스에 연결된 GameData를 쉽게 찾을 수 있도록 설계
	
	- 에디터용 함수를 실제 서버에서 호출하지 못하도록 예외처리
	- 클라이언트에 KeyBinder 추가, 특정 키에 대해서 기능을 바인딩할 수 있도록 인터페이스 제공
	- 맵 스폰 위치 결정 알고리즘을 통해 플레이어를 스폰할 적절한 위치를 결정
	- 서버에서 맵의 스폰정보를 가지고 실제 객체(Tool, WorldInteractor, Npc)를 스폰할 수 있도록 구조 설계
	
	

* Bug Fix

	- 특정 속성이 리플리케이션 되지 않던 원인 수정
		=> 월드에 존재하지 않는 순간 리플리케이션이 되지 않아 발생하는 문제여서 이를 해결
		
	- 서버와 클라이언트의 스킬 쿨타임이 다른 현상 수정
		=> os.clock()함수를 사용하여서 시간이 동기화가 되지 않아서 os.time()으로 변경
	
	- 아이템 장착 시 리플리케이션 순서 문제 해결
		Tool이 갱신되는 도중 이벤트로 EquipSlots 갱신 패킷을 보냈더니 해당 Tool이 갱신되지 않은 상황이 발생
		=> 이벤트를 바인딩하여 처리하지 않고 리플레케이션이 완료되면 패킷을 보내 처리하여 해결



* Porting to Rojo

	- Rojo로 빌드된 프로젝트로 바로 작업할 수 있도록 기본적으로 모든 환경을 포팅(모든 소스 코드, 리소스 등)
	- 폴리곤 데이터의 집합체(맵, 무기) 등은 파일로 추출하여 Rojo에서 그대로 사용
	- 서버 클라이언트 통신에 쓰이는 RemoteEvents, RemoteValues를 간단히 Rojo의 .model.json 기능을 활용하여 간단히 정의