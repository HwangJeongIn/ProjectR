<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="85">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">0</token>
			<string name="CollisionGroups">Default^0^-1</string>
			<Ref name="CurrentCamera">RBXD09B5D1F5FBA40DF994D576C60B7D656</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<token name="HumanoidOnlySetCollisionsOnStateChange">0</token>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsInertiaAndVolumeFix">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SignalBehavior">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<token name="UnionsScaleNonuniformly">0</token>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730001ed9e</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBXD09B5D1F5FBA40DF994D576C60B7D656">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>6.42489481</X>
					<Y>32.466568</Y>
					<Z>46.5199051</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>-0</R02>
					<R10>-0</R10>
					<R11>0.780868888</R11>
					<R12>0.624694943</R12>
					<R20>0</R20>
					<R21>-0.624694943</R21>
					<R22>0.780868888</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>6.42489481</X>
					<Y>12.466567</Y>
					<Z>21.5198994</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020852</UniqueId>
			</Properties>
		</Item>
		<Item class="Part" referent="86">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Baseplate</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac730002090b</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1.20000005</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="Script" referent="87">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{15BFC791-4CE0-46FF-AE2C-D3EE6CC86D62}</string>
					<ProtectedString name="Source"><![CDATA[--[[
mytable = {}
mymetatable = {value1 = 2}
setmetatable(mytable, mymetatable)

mymetatable1 = getmetatable(mytable)
mymetatable1.value1 = 3

mytable1 = setmetatable({},{})
--]]



























--table1.__index = function(table, key) return table[key] end
--table1.__index = table1



-- 메타테이블로 사용할 수 있는 테이블 정의 객체지향 관점에서 상속받아 사용할 수 있다.
table1 = { value1 = 1, value2 = 2, value3 = 3}
table1.__index = table1
--table1.__index = function(table, key) return table[key] end

--local temp = table1.__index
--print(table1.__index)

--local temp2 = table1
--local rv = temp2(table1, "value1")

table2 = setmetatable({ value4 = 4, value5 = 5}, table1)
table2.__index = table2

--print(table2.value1)



local a = 3
local b = 2]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac730002090c</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="88">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script1</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{EE524609-7F01-4886-8B04-A6BBF941D8F6}</string>
					<ProtectedString name="Source"><![CDATA[local function GetValueByKey(table, key)
	
if table[key] then return table[key] end
	
	-- 메타테이블에서 추가로 찾아본다.	
	local metatable = getmetatable(table)
	
	if not metatable or not metatable.__index then return nil end
	
	return metatable.__index(key)
	
end

local table1 = {
	value1 = 1,
	value2 = 2,
	value3 = 3,
	print = function() print("print function in table1") end,
	printValue = function(value) print("printValue function in table1 => " .. tostring(value)) end
}

--table1.__index = table1

--[[
table1.__index = function(table, key) 
	return table[key] 
end
--]]

local table2 = setmetatable({
	value4 = 4,
	value5 = 5}, table1)

local metatableOftable2 = getmetatable(table2)
--local rv = metatableOftable2.__index.value1
local rv2 = table2["value1"]


--local table3 = {}
--local metatableOftable3 = getmetatable(table3)

GetValueByKey(table2, "value1")


--table2.print()
--table2.printValue()




local a = 3
local b = 2]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac730002090d</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="89">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script2</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{FE273AF0-ECD0-4CD5-93D2-96E5C592B3B6}</string>
					<ProtectedString name="Source"><![CDATA[Window = {}
WindowBase = {x=0, y=0, width=50, height=70,}

function Window.new (o)
	setmetatable(o, WindowBase)
	return o
end

WindowBase.__index = function (table, key, input)
	local a = 3
	local b = 2
	local metatable = getmetatable(table)
	print("table : " .. tostring(table))
	print(table)
	print("key : " .. tostring(key))
	print("input : " .. tostring(input))
	return metatable[key]
end

w = Window.new{x=10, y=20}
w2 = Window.new{x=10, y=20}
--[[

print(tostring(w))
print(tostring(w2))


--local test = WindowBase.__index.width

print("w : " .. tostring(w))
print(w.width)
print(w.height)
print(w.x)

--]]]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac730002090e</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="90">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="ManualActivationOnly">false</bool>
				<string name="Name">Sword</string>
				<bool name="RequiresHandle">true</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Content name="TextureId"><null></null></Content>
				<string name="ToolTip"></string>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac730002090f</UniqueId>
			</Properties>
			<Item class="Script" referent="91">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Damager</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{604497F2-8E79-4108-BE5C-18AE4AF50EE8}</string>
					<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------

local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))
local Utility = ServerModuleFacade.Utility
local Debug = ServerModuleFacade.Debug
local ServerConstant = ServerModuleFacade.ServerConstant
local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage

local GameDataType = ServerModuleFacade.ServerEnum.GameDataType

local ToolBase = Utility.DeepCopy(require(ServerModuleFacade.ToolModule:WaitForChild("ToolBase")))
local Debris = game:GetService("Debris")

local Tool = script.Parent
local Anim1 = Tool.anim1
local isAttacking = false

ToolBase:InitializeAll(GameDataType.Tool, Tool)

-- 함수 정의 ------------------------------------------------------------------------------------------------------

function CanAttack(otherPart)
	
	if not otherPart then
		Debug.Assert(false, "대상이 존재하지 않습니다.")
		return false
	end
	
	local otherModel = otherPart.Parent
	if not otherModel then
		Debug.Assert(false, "모델이 존재하지 않습니다.")
		return false
	end
	
	if not Tool then
		Debug.Assert(false, "도구가 없습니다.")
		return false
	end
	
	local toolParent = Tool.Parent
	local toolParentClassName = toolParent.ClassName
	if not toolParentClassName 
		or toolParentClassName == "Workspace" 		-- 필드에 존재
		or toolParentClassName == "Backpack" then	-- 가방에 존재
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	-- 자기자신인 경우
	if toolParent == otherModel then
		return false
	end
	
	return true
	
end

function CalcDamage(attackerCharacter, attackeeCharacter)
	
	local attackerSTR = 0
	local attackeeDEF = 0
	
	-- ==== 캐릭터 계산 ====
	local attackerCharacterGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Character)
	local attackeeCharacterGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Character)
	
	-- 캐릭터 공격 데이터
	if not attackerCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackerCharacter.Name)
	else
		attackerSTR += attackerCharacterGameData.STR
	end
	
	-- 캐릭터 방어 데이터
	if not attackeeCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackeeCharacter.Name)
	else
		attackeeDEF += attackeeCharacterGameData.DEF
	end
	
	-- ==== 도구 계산 =====
	local attackerToolGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Tool)
	local attackeeToolGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Tool)
	
	-- 도구 공격 데이터
	if attackerToolGameData and attackerToolGameData.STR then
		attackerSTR += attackerToolGameData.STR
	end
	-- 도구 방어 데이터
	if attackeeToolGameData and attackeeToolGameData.DEF then
		attackeeDEF += attackeeToolGameData.DEF
	end
	
	
	local finalDamage = ServerConstant.DefaultAttackPoint + (attackerSTR * ServerConstant.DefaultSTRFactor) - attackeeDEF
	
	finalDamage = math.clamp(finalDamage, 0, 100)
	
	return finalDamage
	
end

function AttackCharacter(attackerCharacter, attackeeCharacter)

	local damage = CalcDamage(attackerCharacter, attackeeCharacter)
	Debug.Log("Damage : ".. tostring(damage))
	if damage == 0 then
		return
	end

	local attackeeCharacterHumanoid = attackeeCharacter:FindFirstChild("Humanoid")
	if not attackeeCharacterHumanoid then
		Debug.Assert(false, "Humanoid가 없습니다.")
		return
	end

	attackeeCharacterHumanoid:TakeDamage(damage)
	
end

function Attack(attackeePart)
	
	
	if CanAttack(attackeePart) == false then
		--Debug.Assert(false, "공격할 수 없습니다.")
		return
	end
	
	
	local attackeePlayer = game.Players:GetPlayerFromCharacter(attackeePart.Parent)
	print(attackeePlayer)
	print(attackeePart)
	print(attackeePart.Parent)
	if not attackeePlayer then
		-- 추가해야한다.
		Debug.log("플레이어가 아닙니다.")
	else
		local attackerCharacter = Tool.Parent
		local attackeeCharacter = attackeePart.Parent
		AttackCharacter(attackerCharacter, attackeeCharacter)
	end
	
	
--[[
	local attackerTag = Instance.new("ObjectValue")
	attackerTag.Name = "AttackerTag"
	attackerTag.Value = attackerPlayer
	attackerTag.Parent = attackeeHumanoid
	Debris:AddItem(attackerTag, 3.5)
	--]]
end


function onTouched(otherPart)

	if isAttacking == false then return end
	isAttacking = false
	
	Attack(otherPart)
	
	--[[
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end

		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end

	target:TakeDamage(damage)
	--]]
end


function onActivated()

	--Debug.Assert(false, ToolBase:GetGameDataKey())
	isAttacking = true
	local humanoid = Tool.Parent:FindFirstChild("Humanoid")
	local anim1Track = humanoid:LoadAnimation(Anim1)
	anim1Track:Play()

	anim1Track.Stopped:Connect(function() isAttacking = false end)

	--humanoid:TakeDamage(50)
end


-- 이벤트 바인드
Tool.Activated:Connect(onActivated)
Tool.Attacker.Touched:Connect(onTouched)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020910</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="92">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WeaponController</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{6B2753DD-152E-495C-A764-2A21F28AF566}</string>
					<ProtectedString name="Source"><![CDATA[-- 로컬 변수

local tool = script.Parent
local anim1 = tool.anim1
local damage = 5
local isAttacking = false
local humanoid
local target
local anim1Track


-- 이벤트 함수 정의

local function onTouched(otherPart)
	
	if isAttacking == false then return end
	
	isAttacking = false
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end
	
		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end
	
	target:TakeDamage(damage)
end


local function onActivated()
	
	isAttacking = true
	humanoid = tool.Parent.Humanoid
	anim1Track = humanoid:LoadAnimation(anim1)
	anim1Track:Play()
	
	anim1Track.Stopped:Connect(function() isAttacking = false end)
	
	humanoid:TakeDamage(50)
end


-- 이벤트 바인드
tool.Activated:Connect(onActivated)
tool.Attacker.Touched:Connect(onTouched)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020911</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="93">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="ManualActivationOnly">false</bool>
				<string name="Name">Tool</string>
				<bool name="RequiresHandle">true</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Content name="TextureId"><null></null></Content>
				<string name="ToolTip"></string>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020912</UniqueId>
			</Properties>
			<Item class="Part" referent="94">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Handle</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020913</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>4</X>
						<Y>1.20000005</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Script" referent="95">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Script</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{8934D3BE-DB73-4C06-AD52-0B2273D85E59}</string>
						<ProtectedString name="Source"><![CDATA[
local toolHandle = script.Parent

--local character = script.Parent.Parent


while #game.Players:GetPlayers() < 1 do
	wait(1)
end

for i, player in pairs(game.Players:GetPlayers()) do
	local backpack = player:FindFirstChild("Backpack")
	backpack:Destroy()
end




--toolHandle.Touched= nil
--toolHandle.TouchEnded= nil
--[[
toolHandle.Touched:Connect(function(otherPart)
	print("test!")
end)


toolHandle.TouchEnded:Connect(function(otherPart)
	print("test!2")
end)
--]]
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020914</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Terrain" referent="RBX05AEA7096EEF4E64A25F0EB3150CFA2D">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020916</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX4812612FA9214938BF7823FBEA4BF47B">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0.500003994</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">TestFromRoblox</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac730002cc31</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXD2B58A813AE24C18AAC502E8D98DF9BF">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020806</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX30439A489B944609A9D9C113D4201CD7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020812</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX84823A4C00694586A1992C1747A794A0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020813</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX9EBACB1E6C714F02BD8CC77491852952">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020818</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX976849C0F3D142AE8129501DDB323927">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020819</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX829E3356CDC74D2BA75D862A7EB7F07C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002081b</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX5984321482664414A99B7D68903E244B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002081f</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX0A7730DF3AF5483BAA40D30E9C4241E1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020821</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBXC5764C757AC44D3E8581089E688DA680">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020822</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="PermissionsService" referent="RBX39D5A70148C94D4FB62B2EE8708C16FE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020826</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXBF6ACAB2B17A469A84A050536AC342E0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020828</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXB21F87DFD22A4F47B6BBF91D66374F5E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">0</int64>
			<int64 name="SrcUniverseId">0</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002082b</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="76">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002082c</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="77">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020903</UniqueId>
			</Properties>
			<Item class="Folder" referent="78">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">ClientModule</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020904</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="79">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClientGlobalStorage</string>
						<string name="ScriptGuid">{39160C98-8DA0-4C34-8DD3-D75F0C654B87}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")
local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))

local CommonConstant = require(CommonModule:WaitForChild("CommonConstant"))
local MaxQuickSlotCount = CommonConstant.MaxQuickSlotCount

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType
local StatusType = CommonEnum.StatusType
local ToolType = CommonEnum.ToolType
local ArmorType = CommonEnum.ArmorType

local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local CommonGameDataManager = require(CommonGameDataModule:WaitForChild("CommonGameDataManager"))

local CommonGlobalStorage = require(CommonModule:WaitForChild("CommonGlobalStorage"))
local LocalPlayer = game.Players.LocalPlayer
local PlayerId = LocalPlayer.UserId

local ClientGlobalStorage = {}

function ClientGlobalStorage:Initialize()
	self:SetClientMode()
	self:AddPlayer(PlayerId) -- 본인거는 서버도 통보안해준다.
end

function ClientGlobalStorage:GetData()
	return self.PlayerTable[PlayerId]
end

function ClientGlobalStorage:CheckQuickSlotIndex(quickSlotIndex)
	if MaxQuickSlotCount < quickSlotIndex or quickSlotIndex < 1 then
		Debug.Assert(false, "슬롯인덱스가 비정상입니다. [QuickSlot] => " .. tostring(quickSlotIndex))
		return false
	end
	
	return true
end


function ClientGlobalStorage:GetQuickSlot(quickSlotIndex)
	if self:CheckQuickSlotIndex(quickSlotIndex) == false then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end
	
	local data = self:GetData()
	return data[StatusType.QuickSlot][quickSlotIndex]
end

function ClientGlobalStorage:SetQuickSlot(quickSlotIndex, tool)
	
	if self:CheckQuickSlotIndex(quickSlotIndex) == false then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if not tool then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	local data = self:GetData()
	data[StatusType.QuickSlot][quickSlotIndex] = tool
end

function ClientGlobalStorage:SwapQuickSlot(quickSlotIndex1, quickSlotIndex2)
	if self:CheckQuickSlotIndex(quickSlotIndex1) == false or self:CheckQuickSlotIndex(quickSlotIndex2) == false then
		Debug.Assert(false, "비정상입니다.")
		return false
	end

	local tool1 = self:GetQuickSlot(quickSlotIndex1)
	local tool2 = self:GetQuickSlot(quickSlotIndex2)
	
	if self:SetQuickSlot(quickSlotIndex1, tool2) == false or self:SetQuickSlot(quickSlotIndex2, tool1) == false then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end



ClientGlobalStorage.__index = Utility.Inheritable__index
ClientGlobalStorage.__newindex = Utility.Inheritable__newindex
setmetatable(ClientGlobalStorage, CommonGlobalStorage)

ClientGlobalStorage:Initialize()

return ClientGlobalStorage
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020905</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="80">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">KeyBinder</string>
						<string name="ScriptGuid">{83A77379-54C1-4ED1-AD4F-4DCA1A0A6966}</string>
						<ProtectedString name="Source"><![CDATA[game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)

local UserInputService = game:GetService("UserInputService")			-- 선택해야한다.
local ContextActionService = game:GetService("ContextActionService")	-- 선택해야한다.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))
local Debug = CommonModuleFacade.Debug
local Utility = CommonModuleFacade.Utility

local LocalPlayer = game.Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local GuiPlayerStatus = PlayerGui:WaitForChild("GuiPlayerStatus")
local GuiPlayerStatusWindow = GuiPlayerStatus:WaitForChild("GuiPlayerStatusWindow")



local KeyBinder = {}
KeyBinder.__index = Utility.Inheritable__index
KeyBinder.__newindex = Utility.Inheritable__newindex


local KeyToActionMappingTable = {
	[Enum.KeyCode.One] = {},
	[Enum.KeyCode.Two] = {},
	[Enum.KeyCode.Three] = {},
	[Enum.KeyCode.Four] = {},
	[Enum.KeyCode.Five] = {},
	--[Enum.KeyCode.Backquote] = {},
	[Enum.KeyCode.Q] = {},
	[Enum.KeyCode.E] = {},
	[Enum.KeyCode.R] = {}
}


local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace

local GuiPlayerStatusGuiTweenInfo = TweenInfo.new(
	.5, -- Time
	Enum.EasingStyle.Linear,--Enum.EasingStyle.Back, --Enum.EasingStyle.Linear, -- EasingStyle
	Enum.EasingDirection.In, -- EasingDirection
	0, -- RepeatCount (when less than zero the tween will loop indefinitely)
	false, -- Reverses (tween will reverse once reaching it's goal)
	0 -- DelayTime
)

--local tween = TweenService:Create(part, GuiInventoryTweenInfo, {Position = Vector3.new(0, 0, 0)})

function BindDefaultAction()
	ContextActionService:BindAction(
		"GuiPlayerStatusToggleKey",
		function(actionName, inputState, inputObject)
			if (inputState == Enum.UserInputState.Begin) then
				if GuiPlayerStatus.Enabled then
					GuiPlayerStatusWindow.Position = UDim2.new(0.3,0,.5,0)
					--local tween = TweenService:Create(GuiPlayerStatusWindow, GuiPlayerStatusGuiTweenInfo, { Position = UDim2.new(0,0,.5,0)})
					--tween:Play()
				else
					local tween = TweenService:Create(GuiPlayerStatusWindow, GuiPlayerStatusGuiTweenInfo, { Position = UDim2.new(.5,0,.5,0)})
					tween:Play()

				end
				GuiPlayerStatus.Enabled = not GuiPlayerStatus.Enabled
			end
		end,
		true, Enum.KeyCode.Backquote)
end

function KeyBinder:Initialize()
	
	BindDefaultAction()
	
	for keyCode, actionTable in pairs(KeyToActionMappingTable) do
		
		local actionName = tostring(keyCode)
		
		ContextActionService:BindAction(
			actionName,
			function(actionName, inputState, inputObject)
				if (inputState == Enum.UserInputState.Begin) then
					for _, action in pairs(actionTable) do
						action(actionName, inputState, inputObject)
					end
				end
			end,
			true, keyCode)
		--[[
		ContextActionService:BindActionAtPriority(
			actionName,
			function(keyCode, action, actionName) 
				for actionName, action in pairs(actionTable) do
					action(keyCode, action, actionName)
				end
			end,
			true, 1, keyCode) -- 1은 우선순위
		--]]
	end
end


function KeyBinder:CheckKey(keyCode)
	if not KeyToActionMappingTable[keyCode] then
		Debug.Assert(false, "해당 키는 사용할 수 없습니다. => " .. tostring(keyCode))
		return false
	end
	
	return true
end

function KeyBinder:UnbindActions(keyCode)
	if self:CheckKey(keyCode) == false then
		Debug.Assert(false, "비정상입니다.")
		return
	end
	
	local targetTable = KeyToActionMappingTable[keyCode]
	for key, _ in pairs(targetTable)  do
		targetTable[key] = nil
	end
end

function KeyBinder:BindAction(keyCode, action, actionName)
	if self:CheckKey(keyCode) == false then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if not actionName then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if not action then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	local typeString = type(action)
	if typeString ~= "function" then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	local targetTable = KeyToActionMappingTable[keyCode]
	targetTable[actionName] = action
	
end

function KeyBinder:BindSingleAction(keyCode, action, actionName)
	if self:CheckKey(keyCode) == false then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	self:UnbindActions(keyCode)
	
	if not actionName then
		actionName = 1
	end
	
	if action then
		if self:BindAction(keyCode, action, actionName) == false then
			Debug.Assert(false, "비정상입니다.")
			return false
		end
	end
	
	return true
end


KeyBinder:Initialize()

--[[
KeyBinder:BindSingleAction(Enum.KeyCode.One, function() 
	print("test!!!@@#!")
	KeyBinder:BindSingleAction(Enum.KeyCode.Two, function() print("i'm two!!") end)
end)
--]]
return KeyBinder

--[[
local character = nil
local player = nil

if true then
	player = script.Parent.Parent
else
	character = script.Parent
	player = game.Players:GetPlayerFromCharacter(character)
end

local backpack = player:FindFirstChild("Backpack")
local UserInputService = game:GetService("UserInputService")

local caseSelector = {
	[Enum.KeyCode.One] = function() end
}


local function handleOne1(actionName, inputState, inputObject)
	print("handleOne1 => " .. actionName)
end

local function handleOne2(actionName, inputState, inputObject)
	print("handleOne2 => " .. actionName)
end


local function handleOne3(actionName, inputState, inputObject)
	print("handleOne3 => " .. actionName)
end

local function handleOne4(actionName, inputState, inputObject)
	print("handleOne4 => " .. actionName)
end

local ContextActionService = game:GetService("ContextActionService")
ContextActionService:BindAction("One3", handleOne3, true, Enum.KeyCode.One)
ContextActionService:BindAction("One4", handleOne4, true, Enum.KeyCode.One)

ContextActionService:BindActionAtPriority("One1", handleOne1, true, 2, Enum.KeyCode.One)
ContextActionService:BindActionAtPriority("One2", handleOne2, true, 1, Enum.KeyCode.One)

return {}
--]]
--[[


local function onInputBegan(inputObject, gameProcessedEvent)
	-- First check if the "gameProcessedEvent" is true
	-- This indicates that another script had already processed the input, so this one can be ignored
	if gameProcessedEvent then return end
	-- Next, check that the input was a keyboard event
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		print("A key was released: " .. inputObject.KeyCode.Name)

		--if Enum.KeyCode. ==
		local starterGui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")

		local a = 3
	end
end

local function onInputEnded(inputObject, gameProcessedEvent)
	-- First check if the "gameProcessedEvent" is true
	-- This indicates that another script had already processed the input, so this one can be ignored
	if gameProcessedEvent then return end
	-- Next, check that the input was a keyboard event
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		print("A key was released: " .. inputObject.KeyCode.Name)

		--if Enum.KeyCode. ==
	end
end


UserInputService.InputEnded:Connect(onInputEnded)
UserInputService.InputBegan:Connect(onInputBegan)
--]]]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020906</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="81">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClientModuleLoader</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{1B565CB3-DFFC-416E-B272-5167D7F26178}</string>
					<ProtectedString name="Source"><![CDATA[local StarterPlayer = game:GetService("StarterPlayer")
local StarterPlayerScripts = StarterPlayer:WaitForChild("StarterPlayerScripts")
local ClientModule = StarterPlayerScripts:WaitForChild("ClientModule")

require(ClientModule:WaitForChild("KeyBinder"))
require(ClientModule:WaitForChild("ClientGlobalStorage"))
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020907</UniqueId>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="82">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CustomInventory</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{ADF701D1-7F6A-4093-8CA1-E980459F04FF}</string>
					<ProtectedString name="Source"><![CDATA[--[[

game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)

local character = nil
local player = nil

if true then
	player = script.Parent.Parent
else
	character = script.Parent
	player = game.Players:GetPlayerFromCharacter(character)
end

local backpack = player:FindFirstChild("Backpack")
local UserInputService = game:GetService("UserInputService")

local caseSelector = {
	[Enum.KeyCode.One] = function() end
}

local function onInputBegan(inputObject, gameProcessedEvent)
	-- First check if the "gameProcessedEvent" is true
	-- This indicates that another script had already processed the input, so this one can be ignored
	if gameProcessedEvent then return end
	-- Next, check that the input was a keyboard event
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		print("A key was released: " .. inputObject.KeyCode.Name)

		--if Enum.KeyCode. ==
		local starterGui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
		
		local a = 3
	end
end

local function onInputEnded(inputObject, gameProcessedEvent)
	-- First check if the "gameProcessedEvent" is true
	-- This indicates that another script had already processed the input, so this one can be ignored
	if gameProcessedEvent then return end
	-- Next, check that the input was a keyboard event
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		print("A key was released: " .. inputObject.KeyCode.Name)
		
		--if Enum.KeyCode. ==
	end
end


UserInputService.InputEnded:Connect(onInputEnded)
	UserInputService.InputBegan:Connect(onInputBegan)
	
	--]]
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020908</UniqueId>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="83">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">InstanceTest</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{45E241F9-18C1-4155-A7DA-89B387FF1477}</string>
					<ProtectedString name="Source"><![CDATA[
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local InstanceTestSTC = ReplicatedStorage:WaitForChild("InstanceTestSTC")
local InstanceTestModule = require(ReplicatedStorage:WaitForChild("InstanceTestModule"))

InstanceTestSTC.OnClientEvent:Connect(function(...)
	
	InstanceTestModule["Client"] = 1
	local args = {...}
	for _, arg in ipairs(args) do
		print("TEST!!")
		local temp2 = getmetatable(arg)
		local temp = 3
		
	end
	
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020909</UniqueId>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="84">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PickupManager</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{757E0A25-4388-4C24-823D-76C542030E28}</string>
					<ProtectedString name="Source"><![CDATA[local UIS = game:GetService("UserInputService")
local pickupKey = "F"

local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local PlayerGui = player:WaitForChild("PlayerGui")
local GuiObjectTooltip = PlayerGui:WaitForChild("GuiObjectTooltip")
--local SlotTooltip = PlayerGui:WaitForChild("SlotTooltip")


-- 인벤토리 초기화



local GuiPlayerStatus = PlayerGui:WaitForChild("GuiPlayerStatus")
local GuiPlayerStatusWindow = GuiPlayerStatus:WaitForChild("GuiPlayerStatusWindow")
local GuiEquipSlots = GuiPlayerStatusWindow:WaitForChild("GuiEquipSlots")
local GuiInventory = GuiPlayerStatusWindow:WaitForChild("GuiInventory")

local GuiInventoryItemSlot = GuiInventory:WaitForChild("GuiItemSlot")




function InitializeGuiInventorySlots()
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local CommonMoudleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))
	local CommonConstant = CommonMoudleFacade.CommonConstant
	
	local PlayerGui = player:WaitForChild("PlayerGui")
	local GuiPlayerStatus = PlayerGui:WaitForChild("GuiPlayerStatus")
	local GuiPlayerStatusWindow = GuiPlayerStatus:WaitForChild("GuiPlayerStatusWindow")
	--local GuiEquipSlots = GuiPlayerStatusWindow:WaitForChild("GuiEquipSlots")
	local GuiInventory = GuiPlayerStatusWindow:WaitForChild("GuiInventory")

	local GuiInventoryItemSlot = GuiInventory:WaitForChild("GuiItemSlot")

	
	local MaxInventorySlotCount = CommonConstant.MaxInventorySlotCount
	local GuiInventorySlotCountPerLine = CommonConstant.GuiInventorySlotCountPerLine
	local GuiInventorySlotOffset = CommonConstant.GuiInventorySlotOffset
	
	local GuiInventorySize = GuiInventory.AbsoluteWindowSize
	local finalGuiInventoryWidth = GuiInventorySize.X
	local GuiInventoryWidth = GuiInventory.AbsoluteSize.X
	
	local finalSlotSize = (finalGuiInventoryWidth - (GuiInventorySlotCountPerLine + 1) * GuiInventorySlotOffset) / GuiInventorySlotCountPerLine
	
	local GuiInventorySlotLineCount = math.ceil(MaxInventorySlotCount / GuiInventorySlotCountPerLine)
	
	local finalGuiInventoryHeight = finalSlotSize * GuiInventorySlotLineCount + GuiInventorySlotOffset * (GuiInventorySlotLineCount + 1)
	
	local slotRateX = finalSlotSize / GuiInventoryWidth
	local halfSlotRateX = slotRateX / 2
	local slotRateY = finalSlotSize / finalGuiInventoryHeight
	local halfSlotRateY = slotRateY / 2
	
	local GuiInventoryOffsetRateX =  GuiInventorySlotOffset / GuiInventoryWidth
	local GuiInventoryOffsetRateY =  GuiInventorySlotOffset / finalGuiInventoryHeight
	
	GuiInventoryItemSlot.Size = UDim2.new(slotRateX, 0, slotRateY, 0)
	GuiInventoryItemSlot.Position = UDim2.new(GuiInventoryOffsetRateX + halfSlotRateX, 0, GuiInventoryOffsetRateY + halfSlotRateY, 0)
	GuiInventoryItemSlot.AnchorPoint = Vector2.new(0.5, 0.5)
	
	GuiInventory.CanvasSize = UDim2.new(0, 0, finalGuiInventoryHeight / GuiInventorySize.Y, 0)
	
	local GuiInventorySlotMap = {}
	for y = 0, (GuiInventorySlotLineCount -1) do
		for x = 0, (GuiInventorySlotCountPerLine - 1) do
			
			local newGuiInventorySlot = GuiInventoryItemSlot:Clone()
			local slotIndex = y * GuiInventorySlotCountPerLine + x
			newGuiInventorySlot.Position += UDim2.new((GuiInventoryOffsetRateX + slotRateX) * x, 0, (GuiInventoryOffsetRateY + slotRateY) * y, 0)
			newGuiInventorySlot.Parent = GuiInventory
			newGuiInventorySlot.Name = tostring(slotIndex)
			GuiInventorySlotMap[slotIndex] = newGuiInventorySlot
		end
	end
	
	GuiInventoryItemSlot:Destroy()
	return GuiInventorySlotMap
end


InitializeGuiInventorySlots()


UIS.InputChanged:Connect(function(input)
	
	if mouse.Target then
		local target = mouse.Target.Parent
		if target.ClassName == "Tool" then

			GuiObjectTooltip.Adornee = mouse.Target
			GuiObjectTooltip.GuiObjectName.Text = target.Name

			GuiObjectTooltip.Enabled = true
			-- targetParent.Name
		else
			GuiObjectTooltip.Adornee = nil
			GuiObjectTooltip.Enabled = false
		end
		--if mouse.Target:FindFirstChild("")
	end
		
end)

UIS.InputEnded:Connect(function(input)
	if input.KeyCode == Enum.KeyCode[pickupKey] then
		if mouse.Target then
			local target = mouse.Target.Parent
			if target.ClassName == "Tool" then
				local distanceFromItem = player:DistanceFromCharacter(mouse.Target.Position)
	
				if distanceFromItem < 30 then
					print("pick up!")
				end
			end
		end
	end
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac730002090a</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXFC5C094AD6A34BEAB79C09324F374007">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020917</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="68">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002082d</UniqueId>
		</Properties>
		<Item class="Tool" referent="69">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="ManualActivationOnly">false</bool>
				<string name="Name">Axe</string>
				<bool name="RequiresHandle">true</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Content name="TextureId"><null></null></Content>
				<string name="ToolTip"></string>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208fc</UniqueId>
			</Properties>
			<Item class="Script" referent="70">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AxeController2</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{F5255488-F43C-465B-88F4-CA9E3142A666}</string>
					<ProtectedString name="Source"><![CDATA[local tool = script.Parent

local function explode(point)
	local e = Instance.new("Explosion")
	e.DestroyJointRadiusPercent = 0 -- Make the explosion non-deadly 
	e.Position = point
	e.Parent = workspace
end

local function onActivated()
	-- Get the Humanoid that Activated the tool
	print("onActivated")
	local human = tool.Parent.Humanoid
	-- Call explode with the current point the Humanoid is targetting
	explode(tool.Parent.HumanoidRootPart.Position) 
end

tool.Activated:Connect(onActivated)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208fd</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="71">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Damager</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{CDA4ABB6-F0DC-4107-9063-21F73A01A5AA}</string>
					<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------

local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))
local Utility = ServerModuleFacade.Utility
local Debug = ServerModuleFacade.Debug
local ServerConstant = ServerModuleFacade.ServerConstant
local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage

local GameDataType = ServerModuleFacade.ServerEnum.GameDataType

local ToolBase = Utility.DeepCopy(require(ServerModuleFacade.ToolModule:WaitForChild("ToolBase")))
local Debris = game:GetService("Debris")

local Tool = script.Parent
local Anim1 = Tool.anim1
local isAttacking = false

ToolBase:InitializeAll(GameDataType.Tool, Tool)

-- 함수 정의 ------------------------------------------------------------------------------------------------------

function CanAttack(otherPart)
	
	if not otherPart then
		Debug.Assert(false, "대상이 존재하지 않습니다.")
		return false
	end
	
	local otherModel = otherPart.Parent
	if not otherModel then
		Debug.Assert(false, "모델이 존재하지 않습니다.")
		return false
	end
	
	if not Tool then
		Debug.Assert(false, "도구가 없습니다.")
		return false
	end
	
	local toolParent = Tool.Parent
	local toolParentClassName = toolParent.ClassName
	if not toolParentClassName 
		or toolParentClassName == "Workspace" 		-- 필드에 존재
		or toolParentClassName == "Backpack" then	-- 가방에 존재
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	-- 자기자신인 경우
	if toolParent == otherModel then
		return false
	end
	
	return true
	
end

function CalcDamage(attackerCharacter, attackeeCharacter)
	
	local attackerSTR = 0
	local attackeeDEF = 0
	
	-- ==== 캐릭터 계산 ====
	local attackerCharacterGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Character)
	local attackeeCharacterGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Character)
	
	-- 캐릭터 공격 데이터
	if not attackerCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackerCharacter.Name)
	else
		attackerSTR += attackerCharacterGameData.STR
	end
	
	-- 캐릭터 방어 데이터
	if not attackeeCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackeeCharacter.Name)
	else
		attackeeDEF += attackeeCharacterGameData.DEF
	end
	
	-- ==== 도구 계산 =====
	local attackerToolGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Tool)
	local attackeeToolGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Tool)
	
	-- 도구 공격 데이터
	if attackerToolGameData and attackerToolGameData.STR then
		attackerSTR += attackerToolGameData.STR
	end
	-- 도구 방어 데이터
	if attackeeToolGameData and attackeeToolGameData.DEF then
		attackeeDEF += attackeeToolGameData.DEF
	end
	
	
	local finalDamage = ServerConstant.DefaultAttackPoint + (attackerSTR * ServerConstant.DefaultSTRFactor) - attackeeDEF
	
	finalDamage = math.clamp(finalDamage, 0, 100)
	
	return finalDamage
	
end

function AttackCharacter(attackerCharacter, attackeeCharacter)

	local damage = CalcDamage(attackerCharacter, attackeeCharacter)
	Debug.Log("Damage : ".. tostring(damage))
	if damage == 0 then
		return
	end

	local attackeeCharacterHumanoid = attackeeCharacter:FindFirstChild("Humanoid")
	if not attackeeCharacterHumanoid then
		Debug.Assert(false, "Humanoid가 없습니다.")
		return
	end

	attackeeCharacterHumanoid:TakeDamage(damage)
	
end

function Attack(attackeePart)
	
	
	if CanAttack(attackeePart) == false then
		--Debug.Assert(false, "공격할 수 없습니다.")
		return
	end
	
	
	local attackeePlayer = game.Players:GetPlayerFromCharacter(attackeePart.Parent)
	print(attackeePlayer)
	print(attackeePart)
	print(attackeePart.Parent)
	if not attackeePlayer then
		-- 추가해야한다.
		Debug.Log("플레이어가 아닙니다.")
	else
		local attackerCharacter = Tool.Parent
		local attackeeCharacter = attackeePart.Parent
		AttackCharacter(attackerCharacter, attackeeCharacter)
	end
	
	
--[[
	local attackerTag = Instance.new("ObjectValue")
	attackerTag.Name = "AttackerTag"
	attackerTag.Value = attackerPlayer
	attackerTag.Parent = attackeeHumanoid
	Debris:AddItem(attackerTag, 3.5)
	--]]
end


function onTouched(otherPart)

	if isAttacking == false then return end
	isAttacking = false
	
	Attack(otherPart)
	
	--[[
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end

		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end

	target:TakeDamage(damage)
	--]]
end


function onActivated()

	--Debug.Assert(false, ToolBase:GetGameDataKey())
	isAttacking = true
	local humanoid = Tool.Parent:FindFirstChild("Humanoid")
	local anim1Track = humanoid:LoadAnimation(Anim1)
	anim1Track:Play()

	anim1Track.Stopped:Connect(function() isAttacking = false end)

	--humanoid:TakeDamage(50)
end


-- 이벤트 바인드
Tool.Activated:Connect(onActivated)
Tool.Attacker.Touched:Connect(onTouched)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208fe</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="72">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WeaponController</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{1633AC84-05BF-4397-9FA7-F9DF6698BD4C}</string>
					<ProtectedString name="Source"><![CDATA[-- 로컬 변수

local tool = script.Parent
local anim1 = tool.anim1
local damage = 30
local isAttacking = false
local humanoid
local target
local anim1Track


-- 이벤트 함수 정의

local function onTouched(otherPart)

	if isAttacking == false then return end

	isAttacking = false
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end

		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end

	target:TakeDamage(damage)
end


local function onActivated()

	isAttacking = true
	humanoid = tool.Parent.Humanoid
	anim1Track = humanoid:LoadAnimation(anim1)
	anim1Track:Play()

	anim1Track.Stopped:Connect(function() isAttacking = false end)
end


-- 이벤트 바인드

tool.Activated:Connect(onActivated)
tool.Attacker.Touched:Connect(onTouched)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ff</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="73">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="ManualActivationOnly">false</bool>
				<string name="Name">Sword</string>
				<bool name="RequiresHandle">true</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Content name="TextureId"><null></null></Content>
				<string name="ToolTip"></string>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020900</UniqueId>
			</Properties>
			<Item class="Script" referent="74">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Damager</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{BC7A07D2-06EB-4EBA-81FC-1A3F2D425C9A}</string>
					<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------

local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))
local Utility = ServerModuleFacade.Utility
local Debug = ServerModuleFacade.Debug
local ServerConstant = ServerModuleFacade.ServerConstant
local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage

local GameDataType = ServerModuleFacade.ServerEnum.GameDataType

local ToolBase = Utility.DeepCopy(require(ServerModuleFacade.ToolModule:WaitForChild("ToolBase")))
local Debris = game:GetService("Debris")

local Tool = script.Parent
local Anim1 = Tool.anim1
local isAttacking = false

ToolBase:InitializeAll(GameDataType.Tool, Tool)

-- 함수 정의 ------------------------------------------------------------------------------------------------------

function CanAttack(otherPart)
	
	if not otherPart then
		Debug.Assert(false, "대상이 존재하지 않습니다.")
		return false
	end
	
	local otherModel = otherPart.Parent
	if not otherModel then
		Debug.Assert(false, "모델이 존재하지 않습니다.")
		return false
	end
	
	if not Tool then
		Debug.Assert(false, "도구가 없습니다.")
		return false
	end
	
	local toolParent = Tool.Parent
	local toolParentClassName = toolParent.ClassName
	if not toolParentClassName 
		or toolParentClassName == "Workspace" 		-- 필드에 존재
		or toolParentClassName == "Backpack" then	-- 가방에 존재
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	-- 자기자신인 경우
	if toolParent == otherModel then
		return false
	end
	
	return true
	
end

function CalcDamage(attackerCharacter, attackeeCharacter)
	
	local attackerSTR = 0
	local attackeeDEF = 0
	
	-- ==== 캐릭터 계산 ====
	local attackerCharacterGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Character)
	local attackeeCharacterGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Character)
	
	-- 캐릭터 공격 데이터
	if not attackerCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackerCharacter.Name)
	else
		attackerSTR += attackerCharacterGameData.STR
	end
	
	-- 캐릭터 방어 데이터
	if not attackeeCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackeeCharacter.Name)
	else
		attackeeDEF += attackeeCharacterGameData.DEF
	end
	
	-- ==== 도구 계산 =====
	local attackerToolGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Tool)
	local attackeeToolGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Tool)
	
	-- 도구 공격 데이터
	if attackerToolGameData and attackerToolGameData.STR then
		attackerSTR += attackerToolGameData.STR
	end
	-- 도구 방어 데이터
	if attackeeToolGameData and attackeeToolGameData.DEF then
		attackeeDEF += attackeeToolGameData.DEF
	end
	
	
	local finalDamage = ServerConstant.DefaultAttackPoint + (attackerSTR * ServerConstant.DefaultSTRFactor) - attackeeDEF
	
	finalDamage = math.clamp(finalDamage, 0, 100)
	
	return finalDamage
	
end

function AttackCharacter(attackerCharacter, attackeeCharacter)

	local damage = CalcDamage(attackerCharacter, attackeeCharacter)
	Debug.Log("Damage : ".. tostring(damage))
	if damage == 0 then
		return
	end

	local attackeeCharacterHumanoid = attackeeCharacter:FindFirstChild("Humanoid")
	if not attackeeCharacterHumanoid then
		Debug.Assert(false, "Humanoid가 없습니다.")
		return
	end

	attackeeCharacterHumanoid:TakeDamage(damage)
	
end

function Attack(attackeePart)
	
	
	if CanAttack(attackeePart) == false then
		--Debug.Assert(false, "공격할 수 없습니다.")
		return
	end
	
	
	local attackeePlayer = game.Players:GetPlayerFromCharacter(attackeePart.Parent)
	print(attackeePlayer)
	print(attackeePart)
	print(attackeePart.Parent)
	if not attackeePlayer then
		-- 추가해야한다.
		Debug.log("플레이어가 아닙니다.")
	else
		local attackerCharacter = Tool.Parent
		local attackeeCharacter = attackeePart.Parent
		AttackCharacter(attackerCharacter, attackeeCharacter)
	end
	
	
--[[
	local attackerTag = Instance.new("ObjectValue")
	attackerTag.Name = "AttackerTag"
	attackerTag.Value = attackerPlayer
	attackerTag.Parent = attackeeHumanoid
	Debris:AddItem(attackerTag, 3.5)
	--]]
end


function onTouched(otherPart)

	if isAttacking == false then return end
	isAttacking = false
	
	Attack(otherPart)
	
	--[[
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end

		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end

	target:TakeDamage(damage)
	--]]
end


function onActivated()

	--Debug.Assert(false, ToolBase:GetGameDataKey())
	isAttacking = true
	local humanoid = Tool.Parent:FindFirstChild("Humanoid")
	local anim1Track = humanoid:LoadAnimation(Anim1)
	anim1Track:Play()

	anim1Track.Stopped:Connect(function() isAttacking = false end)

	--humanoid:TakeDamage(50)
end


-- 이벤트 바인드
Tool.Activated:Connect(onActivated)
Tool.Attacker.Touched:Connect(onTouched)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020901</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="75">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WeaponController</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{E660943E-A97D-4458-8BC6-72653856EDA4}</string>
					<ProtectedString name="Source"><![CDATA[-- 로컬 변수

local tool = script.Parent
local anim1 = tool.anim1
local damage = 5
local isAttacking = false
local humanoid
local target
local anim1Track


-- 이벤트 함수 정의

local function onTouched(otherPart)
	
	if isAttacking == false then return end
	
	isAttacking = false
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end
	
		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end
	
	target:TakeDamage(damage)
end


local function onActivated()
	
	isAttacking = true
	humanoid = tool.Parent.Humanoid
	anim1Track = humanoid:LoadAnimation(anim1)
	anim1Track:Play()
	
	anim1Track.Stopped:Connect(function() isAttacking = false end)
	
	humanoid:TakeDamage(50)
end


-- 이벤트 바인드
tool.Activated:Connect(onActivated)
tool.Attacker.Touched:Connect(onTouched)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020902</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterGui" referent="64">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002082e</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
		<Item class="LocalScript" referent="65">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GuiController</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{6E735618-9D46-4328-951D-D92712A1EECB}</string>
				<ProtectedString name="Source"><![CDATA[-- 클라이언트에게 보여주는 GUI이기 때문에 LocalScript 사용


-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- StarterGui UI

local StarterGui = script.Parent

local MainMessageText = StarterGui:WaitForChild("MainMessage").MainMessageText
local EventMessageText = StarterGui:WaitForChild("EventMessage").EventMessageText

local PlayersLeftCountText = StarterGui.PlayersLeftCount.PlayersLeftCountText
local KilledCountText = StarterGui.KilledCount.KilledCountText

local CurrentGameLengthText = StarterGui.CurrentGameLength.CurrentGameLengthText


-- 공통 저장소 변수

local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))
local GameStateType = CommonModuleFacade.CommonEnum.GameStateType
local WinnerType = CommonModuleFacade.CommonEnum.WinnerType


-- 리플리케이션 저장소 변수


--local MainMessage = ReplicatedStorage:WaitForChild("MainMessage")
--MainMessageText.Text = MainMessage.Value

local PlayersLeftCount = ReplicatedStorage:WaitForChild("PlayersLeftCount")
PlayersLeftCountText.Text = PlayersLeftCount.Value

local CurrentGameLength = ReplicatedStorage:WaitForChild("CurrentGameLength")
CurrentGameLengthText.Text = CurrentGameLength.Value

-- Remote Event

local ChangeGameStateSTC = ReplicatedStorage:WaitForChild("ChangeGameStateSTC")
local NotifyWinnerSTC = ReplicatedStorage:WaitForChild("NotifyWinnerSTC")

local ChangeGameDataCTS = ReplicatedStorage:WaitForChild("ChangeGameDataCTS")


PlayersLeftCount:GetPropertyChangedSignal("Value"):Connect(function()
	PlayersLeftCountText.Text = PlayersLeftCount.Value
end)

CurrentGameLength:GetPropertyChangedSignal("Value"):Connect(function()
	CurrentGameLengthText.Text = CurrentGameLength.Value
end)


-- 함수 정의 ------------------------------------------------------------------------------------------------------

local function ToggleInGameGui(isEnabled)
	PlayersLeftCountText.Parent.Enabled = isEnabled
	CurrentGameLengthText.Parent.Enabled = isEnabled
	KilledCountText.Parent.Enabled = isEnabled
end


local function SetMainMessage(inputText)
	
	if inputText == "" then
		
		MainMessageText.Parent.Enabled = false
		
	else
--[[
		local length = inputText:len()
		local boxSize = length * 20 + 40

		if MainMessageText.Size.X.Offset ~= boxSize then
			MainMessageText.Size = UDim2.fromOffset(boxSize, MainMessageText.Size.Y.Offset)
		end

		if MainMessageText.Position.X.Offset ~= (-(boxSize/2)) then
			MainMessageText.Position = UDim2.new(MainMessageText.Position.X.Scale, -(boxSize/2), MainMessageText.Position.Y.Offset, MainMessageText.Position.Y.Scale)
		end
--]]
		MainMessageText.Text = inputText
		MainMessageText.Parent.Enabled = true
	end
end

local function SetEventMessage(inputText)
	
	if inputText == "" then

		EventMessageText.Parent.Enabled = false

	else

		EventMessageText.Text = inputText
		EventMessageText.Parent.Enabled = true
		
		wait(3)

		EventMessageText.Parent.Enabled = false
	end
end


local function ProcessWaiting(arguments)

	print("GameStateType.Waiting in client")
	SetMainMessage("Waiting ... ")
	PlayersLeftCountText.Parent.Enabled = false
	CurrentGameLengthText.Parent.Enabled = false
	KilledCountText.Parent.Enabled = false
	
end


local function ProcessStarting(arguments)

	print("GameStateType.Starting in client")
	for i = 5, 1, -1 do
		SetMainMessage(tostring(i))
		wait(1)
	end
	
end


local function ProcessPlaying(arguments)

	local mapName = arguments[1]
	SetMainMessage(mapName .. " is selected")
	
	wait(2)
	
	SetMainMessage("Get ready to play")
	PlayersLeftCountText.Parent.Enabled = true
	CurrentGameLengthText.Parent.Enabled = true
	KilledCountText.Parent.Enabled = true
	
	wait(2)
	
	SetMainMessage("")
	
end


local function ProcessDead(arguments)

	SetMainMessage("You Died")
	
end


local function ProcessWaitingForFinishing(arguments)
	
	ProcessWaiting()
	
end


local GameStateProcessSelector = {
	[GameStateType.Waiting] = ProcessWaiting,
	[GameStateType.Starting] = ProcessStarting,
	[GameStateType.Playing] = ProcessPlaying,
	[GameStateType.Dead] = ProcessDead,
	[GameStateType.WaitingForFinishing] = ProcessWaitingForFinishing,
}

ChangeGameStateSTC.OnClientEvent:Connect(function(gameState, ...)
	
	print("GameStateType : " .. gameState)
	GameStateProcessSelector[gameState](...)
end)


local WinnerProcessSelector = {
	[WinnerType.Player] = "Winner is ",
	[WinnerType.NoOne_TimeIsUp] = "Time is up",
	[WinnerType.NoOne_AllPlayersWereDead] = "No one won the game",
	[WinnerType.Ai] = "Winner is AI",
}

NotifyWinnerSTC.OnClientEvent:Connect(function(winnerType, winnerName, winnerReward)
	
	local winnerMessageString = WinnerProcessSelector[winnerType]
	local rewardMessageString = ""
	
	if winnerName ~= nil then
		winnerMessageString = winnerMessageString .. winnerName
		if winnerReward ~= nil then
			rewardMessageString = winnerName .. " got " .. tostring(winnerReward) .. " coins"
		end
	end
	
	SetMainMessage(winnerMessageString)
	
	wait(3)
	
	if rewardMessageString then
		SetMainMessage(rewardMessageString)
	end
	
end)


-- 실행 코드 ------------------------------------------------------------------------------------------------------
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f9</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="66">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiEquipSlotController</string>
					<string name="ScriptGuid">{B4219305-171D-4134-A193-189B23DABBDF}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208fa</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="67">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiInventoryController</string>
					<string name="ScriptGuid">{6219607A-8E6E-4A38-9ACA-FBA7E66D6EC8}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208fb</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="LocalizationService" referent="RBXE0D19D57BA604C788F76FC94BC133DBA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020830</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX75BA5427D7F84F5888ED52BCAE299C89">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020834</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX84C54081F4E747FD83E09F96067AD693">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020836</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX0553C824B4254DCD93E300ED7E04D25E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020837</UniqueId>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX385AA3A3231A474984830A91AEB1BB82">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020839</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX94A8A551F4514612A98D06F68050DDB3">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002083b</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXF7DB02B7E10D4548B9899BA0924F45AD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac730002cccd</UniqueId>
				<string name="Value">{C2B8DBFD-FFA5-498E-8798-AEF9772AD2EE}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX5D31997BE8C04306BE29FAF7E76B1365">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002083c</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX3FC196CD997C4226B43A34245472B177">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002083d</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX8CAC4595116A468FAADC89ADF1CA0F1F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002083e</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBXD8879EDDC37942849D0FADDEA58C7E9E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020848</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX28C36A52DB44403F92C7164CCE3AF976">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002084a</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX904832F89336400E9503573A2B98D91C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002084c</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX60D2541BFBC741E1AF6ACAFE0210E11B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002084d</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXE780D1E976B842C59D9FB4468CE9F4E2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002084e</UniqueId>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBX34B16B3A8ACD4E30A9AB48BA7BF6EFA0">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020851</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBXD9F056BD86964D078938330ED4433873">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020854</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="18">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020855</UniqueId>
		</Properties>
		<Item class="Script" referent="20">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GameDataManagerTest</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{375E5265-FE55-4C23-AE48-A890371CD5B3}</string>
				<ProtectedString name="Source"><![CDATA[--[[
local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))
local GameDataManager =  ServerModuleFacade.GameDataManager

local key = 2

local row = GameDataManager.CharacterGameData:Get(key)
if row then
	local temp = row.STR
	local a
end

local testValue = GameDataManager.CharacterGameData[key].STR
--]]
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ce</UniqueId>
			</Properties>
		</Item>
		<Item class="Script" referent="21">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Initializer</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{345BA66E-2B95-4C81-A543-B197E64C98BE}</string>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ChangeGameStateSTC = ReplicatedStorage:WaitForChild("ChangeGameStateSTC")


local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))

local Debug = ServerModuleFacade.Debug
local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage
local ServerGameDataManager = ServerModuleFacade.ServerGameDataManager

local GameStateType = ServerModuleFacade.CommonEnum.GameStateType
local GameDataType = ServerModuleFacade.ServerEnum.GameDataType

local ToolModule = ServerModuleFacade.ToolModule
local DamagerScript = ToolModule:WaitForChild("Damager")
local InteractorScript = ToolModule:WaitForChild("Interactor")

local Tools = ServerStorage:WaitForChild("Tools")


function testFunction()
	
	local Utility = ServerModuleFacade.Utility
	local array = Utility.DeepCopy(ServerModuleFacade.TArray)
	array:Initialize(30)
	array:Set(1,"Test")
	array:Set(30, "Foo")
	array:Set(15, "Bar")
	
	local temp1 = array:Get(30)
	local temp2 = array:Get(15)
	
	local list = Utility.DeepCopy(ServerModuleFacade.TList)
	list:Initialize(20)
	

	local temp3 = list:Get(5)
	for i = 1, 20 do
		list:Push("test" .. tostring(i))
	end
	
	local temp4 = list:Get(21)
	
	local temp5 = list:Pop(3)
	local temp6 = list:PopBack()
	
	for i = 1, list.CurrentCount do
		print(tostring(i) .. tostring(list:Get(i)))
	end
end

--testFunction()



--[[
-- 모듈스크립트 local 변수 테스트
local Utility = ServerModuleFacade.Utility
local CopyTest1 = Utility.DeepCopy(require(ToolModule:WaitForChild("CopyTest")))
local CopyTest2 = Utility.DeepCopy(require(ToolModule:WaitForChild("CopyTest")))

-- 모듈스트립트의 local 변수는 모듈 스크립트 사이에서 공유되는 값이 맞다
CopyTest2:Set(5)
CopyTest2:Print()
CopyTest1:Set(3)
CopyTest2:Print()

local CopyTestScript = (ToolModule:WaitForChild("CopyTestScript"))
local CopyTestScript1 = CopyTestScript:Clone()
local CopyTestScript2 = CopyTestScript:Clone()

-- 일반 스크립트는 local 변수까지 완벽하게 복사된다.
local part1 = Instance.new("Part")
part1.Name = "aaa"
part1.Parent = workspace
CopyTestScript1.Parent = part1

local part2 = Instance.new("Part")
part2.Name = "bbb"
part2.Parent = workspace
CopyTestScript2.Parent = part2
--]]


local function InitializeGlobal()

	
end

local function InitializeTools()
	local toolList = Tools:GetChildren()
	
	local toolCount = #toolList
	for i = 1, toolCount do
		if toolList[i].Damager then
			local clonedDamagerScript = DamagerScript:Clone()
			clonedDamagerScript.Parent = toolList[i]
			
		elseif toolList[i].Interactor then
			local clonedInteractorScript = InteractorScript:Clone()
			clonedInteractorScript.Parent = toolList[i]
			
		else
			ServerModuleFacade.Assert(false, "도구 용도에 맞게 태그를 지정하세요")
		end
	end
	
	local test = 1
end

local function InitializePlayers()
	
	game.Players.PlayerRemoving:Connect(function(player)
		ServerGlobalStorage:RemovePlayer(player)
	end)
	
	game.Players.PlayerAdded:Connect(function(player)
		ServerGlobalStorage:AddPlayer(player)
		
		local leaderstatsFolder = Instance.new("Folder")
		leaderstatsFolder.Name = "leaderstats"
		leaderstatsFolder.Parent = player

		local coins = Instance.new("IntValue")
		coins.Name = "Coins"
		coins.Value = 50
		coins.Parent = leaderstatsFolder
		
		player.CharacterRemoving:Connect(function(character)
			ServerGlobalStorage:ClearPlayer(player)
		end)
		
		-- 캐릭터가 추가되거나 리스폰된 경우 CharacterRemoving도 있음
		player.CharacterAdded:Connect(function(character)
			--ServerGlobalStorage:AddCharacter(character)
			
			local characterGameData = ServerGameDataManager[GameDataType.Character]:Get(1)
			if not characterGameData then
				Debug.Assert(false, "데이터가 존재하지 않습니다.")
			end
			ServerGlobalStorage:AddGameData(character, characterGameData)
			
			--[[
			local characterDataTable = Instance.new("ObjectValue")
			characterDataTable.Name = "CharacterDataTable"
			characterDataTable.Parent = character
			--]]
			
			character.Humanoid.Died:Connect(function()
				-- 죽었을 때
				if character:FindFirstChild("AliveTag")  then
					character.AliveTag:Destroy()
				end

				ChangeGameStateSTC:FireClient(player, GameStateType.Dead)


				--player:LoadCharacterBlocking()


				ChangeGameStateSTC:FireClient(player, GameStateType.WaitingForFinishing)
			end)
		end)
		
		ChangeGameStateSTC:FireClient(player, GameStateType.Waiting)
	end)
	
end

local function InitializeGame()
	
	--Debug.Assert(false, "test")
	InitializeTools()
	InitializePlayers()	
	
end

InitializeGame()


]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208cf</UniqueId>
			</Properties>
		</Item>
		<Item class="Script" referent="22">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">InstanceTest</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{B73EB433-789F-4073-BBF5-F69DA9456B6B}</string>
				<ProtectedString name="Source"><![CDATA[
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local InstanceTestSTC = ReplicatedStorage:WaitForChild("InstanceTestSTC")
local InstanceTestModule = require(ReplicatedStorage:WaitForChild("InstanceTestModule"))

local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))

local ServerEnum = ServerModuleFacade.ServerEnum
local GameDataType = ServerEnum.GameDataType
local ServerGameDataManager = ServerModuleFacade.ServerGameDataManager

local toolGameData = ServerGameDataManager[GameDataType.Tool]:Get(1)
local toolGameDataRaw = getmetatable(toolGameData)


while true do

	wait(5)
	InstanceTestModule["Server"] = 1
	
	local players = game.Players:GetPlayers()
	for _, player in ipairs(players) do
		
		local backpack = player.Backpack
		
		local tools = backpack:GetChildren()
		
		local finalString = ""
		for i, tool in ipairs(tools) do
			InstanceTestSTC:FireClient(player, toolGameData)
			
			
			--print(tool)
			--finalString = finalString .. " / Tool" .. tostring(i) .. " => " .. tostring(tool)
		end
		
		--print(finalString)
		
	end

end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d0</UniqueId>
			</Properties>
		</Item>
		<Item class="Script" referent="23">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{8FB91966-0BBD-4DE0-905A-BB6491B451EA}</string>
				<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------

-- 플레이어에게 복제되는 값들을 저장하는 컨테이너
-- 서버와 모든 플레이어에게 보인다.
-- GUI를 업데이트 하기 위한 MainMessage, MainMessage value 등이 들어간다.

local ReplicatedStorage = game:GetService("ReplicatedStorage")


-- 서버에서만 보이는 스토리지 -- 소드와 맵 등을 저장했다.
-- 다른 플레이어는 보지 못하기 때문에 악용할 수 없다
local ServerStorage = game:GetService("ServerStorage")

local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))
local ServerConstant = ServerModuleFacade.ServerConstant
local IsTestMode = ServerConstant.IsTestMode

-- 게임이 생성되기 전에 스크립트가 먼저 실행될 수 있기 때문에
-- 스크립트 실행 시점에 로드되어 있지 않을 수 있다. 
-- 따라서 WaitForChild를 사용하여 로드될 때까지 기다린다.
local MapsFolder = ServerStorage:WaitForChild("Maps")

local MainMessage = ReplicatedStorage:WaitForChild("MainMessage")
local CurrentGameLength = ReplicatedStorage:WaitForChild("CurrentGameLength")
local PlayerCount = ReplicatedStorage:WaitForChild("PlayerCount")
local PlayersLeftCount = ReplicatedStorage:WaitForChild("PlayersLeftCount")


-- 공통 저장소관련
local GameStateType = ServerModuleFacade.CommonEnum.GameStateType
local WinnerType = ServerModuleFacade.CommonEnum.WinnerType


-- RemoteEvent
local ChangeGameStateSTC = ReplicatedStorage:WaitForChild("ChangeGameStateSTC")
local NotifyWinnerSTC = ReplicatedStorage:WaitForChild("NotifyWinnerSTC")
local ChangeGameDataCTS = ReplicatedStorage:WaitForChild("ChangeGameDataCTS")

ChangeGameDataCTS.OnServerEvent:Connect(function(player, arg1)
	print(arg1 .. " is client message")
	print(MainMessage.Value)
end)


local DefaultReward = 100
local GameLength = 50
local MinPlayerCount = 1
local MaxPlayerCount = 16


local Initializer = require(script:WaitForChild("Initializer"))
local MapController = require(script:WaitForChild("MapController"))


-- 함수 정의 ------------------------------------------------------------------------------------------------------





function ClearGui()
	CurrentGameLength.Value = 0
	PlayersLeftCount.Value = 0
	MainMessage.Value = ""
end




-- 실행 코드 ------------------------------------------------------------------------------------------------------
Initializer:InitializeGame()


while false  do
	
	
	-- 다른 플레이어를 기다리는 중
	
	if IsTestMode then
		while #game.Players:GetPlayers() < 1 do
			wait(1)
		end
		--[[
		if IsTestMode and #game.Players:GetPlayers() < 2 then
			Instance.new("Player", game.Players)
		end
		--]]
	else
		while #game.Players:GetPlayers() < 2 do
			wait(1)
		end
	end

	

	-- 플레이어 저장
	
	local playersInGame = {}
	local players = game.Players:GetPlayers()
	for i, player in pairs(players) do
		
		if not player then
			continue
		end
		
		table.insert(playersInGame, player)
		ChangeGameStateSTC:FireClient(player, GameStateType.Starting)
	end
	

	-- 10초 딜레이
	if IsTestMode then
		wait(1)
	else
		wait(5)
	end

	
	-- 맵 선택
	local clonedMap = MapController:SelectRandomMap()
	
	-- 플레이어 초기화 : SpawnPoint로 이동, 도구 제공 등
	Initializer:EnterGame(clonedMap, playersInGame)
	
	-- 맵 선택 메시지, 게임 시작 메시지
	for i, player in pairs(playersInGame) do

		if not player then
			table.remove(playersInGame, i)
			continue
		end

		ChangeGameStateSTC:FireClient(player, GameStateType.Playing, clonedMap.Name)
	end
	
	local currentGameLength = GameLength
	
	local prevTime = 0
	local elapsedTime = 0
	local currentCharacter = nil
	local finalPlayerCount = #playersInGame

	local winnerType
	local winnerName
	local winnerReward
	
	while true do
		
		prevTime = os.time()
		
		wait(1)
		
		for i, player in pairs(playersInGame) do
			
			if not player then
				-- 플레이어가 떠났을 때
				table.remove(playersInGame, i)
				continue
			end
			
			currentCharacter = player.Character
			
			if not currentCharacter then
				-- 플레이어의 캐릭터가 사망 / 플레이어가 떠났을 때
				table.remove(playersInGame, i)
			else
				if not currentCharacter:FindFirstChild("AliveTag") then
					table.remove(playersInGame, i)
				end
			end
		end
		
		elapsedTime = os.time() - prevTime
		currentGameLength -= elapsedTime
		if currentGameLength < 0 then
			currentGameLength = 0
		end
		
		-- 클라이언트로 리플리케이션
		CurrentGameLength.Value = currentGameLength
		PlayersLeftCount.Value = #playersInGame
		
		-- 게임 종료 조건 확인
		if #playersInGame == 1 then
			
			local reward = (playersInGame[1].KilledCount + (finalPlayerCount / 2)) * DefaultReward
			
			winnerType = WinnerType.Player
			winnerName = playersInGame[1].Name
			winnerReward = reward
			
			playersInGame[1].leaderstats.Coins.Value += reward
			break
			
		elseif #playersInGame == 0 then
			
			winnerType = WinnerType.NoOne_AllPlayersWereDead
			break
			
		elseif currentGameLength <= 0 then
			
			winnerType = WinnerType.NoOne_TimeIsUp
			break
		end
	end

	wait(5)
	if winnerType == WinnerType.Player then
		NotifyWinnerSTC:FireAllClients(winnerType, winnerName, winnerReward)
	else
		NotifyWinnerSTC:FireAllClients(winnerType)
	end
	
	if IsTestMode then
		wait(10)
	end
	
	-- 맵 정리
	
	Initializer:ClearPlayers(playersInGame)
	ClearGui()
	clonedMap:Destroy()
	
	wait(5)
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d1</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="24">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Initializer</string>
					<string name="ScriptGuid">{D1A3FE55-9A4A-442E-901A-1805B55461D0}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ChangeGameStateSTC = ReplicatedStorage:WaitForChild("ChangeGameStateSTC")


local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))

local Debug = ServerModuleFacade.Debug
local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage
local ServerGameDataManager = ServerModuleFacade.ServerGameDataManager

local GameStateType = ServerModuleFacade.CommonEnum.GameStateType
local GameDataType = ServerModuleFacade.ServerEnum.GameDataType

local ToolModule = ServerModuleFacade.ToolModule
local DamagerScript = ToolModule:WaitForChild("Damager")
local InteractorScript = ToolModule:WaitForChild("Interactor")

local Tools = ServerStorage:WaitForChild("Tools")
local MapController = require(script.Parent:WaitForChild("MapController"))

local Initializer = {}


function InitializeTools()
	local toolList = Tools:GetChildren()

	local toolCount = #toolList
	for i = 1, toolCount do
		if toolList[i].Damager then
			local clonedDamagerScript = DamagerScript:Clone()
			clonedDamagerScript.Parent = toolList[i]

		elseif toolList[i].Interactor then
			local clonedInteractorScript = InteractorScript:Clone()
			clonedInteractorScript.Parent = toolList[i]

		else
			ServerModuleFacade.Assert(false, "도구 용도에 맞게 태그를 지정하세요")
		end
	end
end

function ClearPlayer(player)
	if not player then
		return false
	end
	
	-- 캐릭터가 존재하면 존재하는 캐릭터 정리 -- 없는 경우에도 들어올 수 있다.
	local character = player.Character
	if character then
		-- 데이터 기반으로 수정해야 된다.
		if character:FindFirstChild("AliveTag") then
			character.AliveTag:Destroy()
		end
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then 
			humanoid:UnequipTools()
		end
	else
		Debug.Assert(false, "왜 발생하는지 파악해야 합니다. => ".. player.Name)
	end
	
	-- 플레이어 가방 정리
	player.Backpack:ClearAllChildren()

	-- 플레이어 데이터 정리
	if not ServerGlobalStorage:ClearPlayer(player) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end

function OnCharacterAdded(player, character)
	--[[
	local characterGameData = ServerGameDataManager[GameDataType.Character]:Get(1)
	if not characterGameData then
		Debug.Assert(false, "데이터가 존재하지 않습니다.")
	end
	ServerGlobalStorage:AddGameData(character, characterGameData)
	--]]
	
	character.Humanoid.Died:Connect(function()
		-- 죽었을 때
		if character:FindFirstChild("AliveTag")  then
			character.AliveTag:Destroy()
		end
		ChangeGameStateSTC:FireClient(player, GameStateType.Dead)
		--player:LoadCharacterBlocking()
		ChangeGameStateSTC:FireClient(player, GameStateType.WaitingForFinishing)
	end)
end

function OnCharacterRemoving(player, character)
	ClearPlayer(player)
end

function OnPlayerAdded(player)
	player.CharacterAdded:Connect(function(character)
		OnCharacterAdded(player, character)
	end)

	player.CharacterRemoving:Connect(function(character)
		OnCharacterRemoving(player, character)
	end)
	
	ServerGlobalStorage:AddPlayer(player)

	local leaderstatsFolder = Instance.new("Folder")
	leaderstatsFolder.Name = "leaderstats"
	leaderstatsFolder.Parent = player

	local coins = Instance.new("IntValue")
	coins.Name = "Coins"
	coins.Value = 50
	coins.Parent = leaderstatsFolder
	
	ChangeGameStateSTC:FireClient(player, GameStateType.Waiting)
end

function OnPlayerRemoving(player)
	ServerGlobalStorage:RemovePlayer(player)
end

function RegisterPlayerEvent()
	game.Players.PlayerAdded:Connect(OnPlayerAdded)
	game.Players.PlayerRemoving:Connect(OnPlayerRemoving)
end

function Initializer:InitializeGame()
	InitializeTools()
	RegisterPlayerEvent()
end

function Initializer:ClearPlayers(players)
	for i, player in pairs (players) do
		
		if not ClearPlayer(player) then
			Debug.Assert(false, "플레이어 데이터 정리에 실패했습니다. => " .. player.Name)
			continue
		end
	end
end

function Initializer:StartGame(playersInGame)
	for i, player in pairs (playersInGame) do

		if not player then
			Debug.Log("이미 나간 플레이어입니다. => " .. player.Name)
			table.remove(playersInGame, i)
			continue
		end

		local character = player.Character
		if not character then
			Debug.Assert(false, "플레이어의 캐릭터가 없습니다. 게임에서 제외됩니다. => " .. player.Name)
			table.remove(playersInGame, i)
			continue
		end
		
		-- 기본 도구
		local sword = ServerStorage.Tools.Sword:Clone()
		sword.Parent = player.Backpack

		local axe = ServerStorage.Tools.Axe:Clone()
		axe.Parent = player.Backpack

		--[[
		local boolValue = Instance.new("BoolValue")
		boolValue.Name = "BoolValue!!"
		boolValue.Parent = sword

		local temp = require(ServerModuleFacade.ToolModule.ToolBase)
		temp.Name = "temp"
		temp.Parent = sword
		
		local temp2 = temp:Clone()
		temp2.Parent = sword
		--]]
		-- 플레이어 생존 여부 확인을 위한 태그
		if not character:FindFirstChild("AliveTag") then
			local aliveTag = Instance.new("BoolValue")
			aliveTag.Name = "AliveTag"
			aliveTag.Parent = character
		end
	end
end

function Initializer:EnterGame(map, playersInGame)
	MapController:EnterMap(map, playersInGame)
	self:StartGame(playersInGame)
end


return Initializer


]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d2</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="25">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MapController</string>
					<string name="ScriptGuid">{72719500-8D54-4785-B93C-C344F6C38028}</string>
					<ProtectedString name="Source"><![CDATA[local ServerStorage = game:GetService("ServerStorage")
local MapsFolder = ServerStorage:WaitForChild("Maps")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))
local Debug = ServerModuleFacade.Debug

local MapController = {}

function MapController:DivideWithoutRemainder(value, divisor)
	return (value - (value % divisor)) / divisor
end

function MapController:TestSpawnPoints(spawnPoints, centerPosition, mapBase)
	-- 테스트
	print("Center : ".. tostring(centerPosition))
	for i, pos in pairs (spawnPoints) do
		local clonedobject = mapBase.Parent:FindFirstChild("Cactus"):Clone()
		clonedobject.Parent = workspace

		clonedobject:SetPrimaryPartCFrame(CFrame.lookAt(Vector3.new(pos.X, pos.Y + 5.0, pos.Z), centerPosition))
		--clonedobject:MoveTo(pos)
		-- SetPrimaryPartCFrame ( CFrame cframe )
		print(tostring(i).. " : ".. tostring(pos))
	end
end

function MapController:CalcSpawnPoints(playerCount, mapBase)

	--playerCount = 4

	local splitCount = 1

	local splitFactor = MapController:DivideWithoutRemainder(playerCount, 4);
	if playerCount % 4 ~= 0 then
		splitFactor += 1
	end

	splitCount += 2 * splitFactor
	local sidePerPlayerCount = MapController:DivideWithoutRemainder(splitCount, 2);

	local centerPosition = mapBase.Position
	local xLengthPerSector = mapBase.Size.X / splitCount
	local zLengthPerSector  = mapBase.Size.Z / splitCount

	local rv = {}

	local currentPosition = centerPosition - Vector3.new(xLengthPerSector * sidePerPlayerCount, 0, zLengthPerSector * sidePerPlayerCount)

	currentPosition = currentPosition + Vector3.new(0, 0, zLengthPerSector)
	for  i = 1, sidePerPlayerCount, 1 do
		table.insert(rv, currentPosition)
		table.insert(rv, Vector3.new(currentPosition.X + (splitCount -1) * xLengthPerSector, currentPosition.Y, currentPosition.Z))

		currentPosition = currentPosition + Vector3.new(0, 0, zLengthPerSector * 2)
	end


	currentPosition = centerPosition - Vector3.new(xLengthPerSector * sidePerPlayerCount, 0, zLengthPerSector * sidePerPlayerCount)

	currentPosition = currentPosition + Vector3.new(xLengthPerSector, 0, 0)
	for  i = 1, sidePerPlayerCount, 1 do
		table.insert(rv, currentPosition)
		table.insert(rv, Vector3.new(currentPosition.X, currentPosition.Y, currentPosition.Z + ((splitCount -1) * xLengthPerSector)))

		currentPosition = currentPosition + Vector3.new(xLengthPerSector * 2, 0, 0)
	end

	return rv
end

function MapController:TeleportPlayerToSpawnPoint(character, spawnPoint, mapCenterPosition)
	local rayLength = 100
	local rayDirection = Vector3.new(0, -rayLength, 0)

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")


	local rayOrigin = Vector3.new(spawnPoint.X, spawnPoint.Y + rayLength, spawnPoint.Z)

	local raycastParams = RaycastParams.new()
	--raycastParams.FilterDescendantsInstances = {character.Parent}
	--raycastParams.FilterType = CommonEnum.RaycastFilterType.Blacklist
	local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

	local finalPosition = rayOrigin
	if raycastResult then
		finalPosition = raycastResult.Position
	end

	humanoidRootPart.CFrame = CFrame.lookAt(finalPosition, mapCenterPosition)
end


function MapController:TeleportPlayerToRespawnLocation(player)
	if not player then
		Debug.Assert(false, "플레이어가 없습니다.")
		return
	end
	
	local character = player.Character
	if not character then
		Debug.Assert(false, "플레이어의 캐릭터가 없습니다.")
		return
	end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	humanoidRootPart.CFrame = player.RespawnLocation.CFrame
end

function MapController:SelectRandomMap()
	local mapCandidates = MapsFolder:GetChildren()
	local mapCount = #mapCandidates
	if mapCount == 0 then
		Debug.Assert(false, "맵이 없습니다.")
		return nil
	end
	
	local chosenMap = mapCandidates[math.random(1, #mapCandidates)]
	local clonedMap = chosenMap:Clone()
	clonedMap.Parent = workspace
	
	return clonedMap
end

function MapController:EnterMap(map, playersInGame)

	local playerCount = #playersInGame
	local mapBase = map:WaitForChild("Base")
	local mapCenterPosition = mapBase.Position
	local spawnPointList = self:CalcSpawnPoints(playerCount, mapBase)

	for i, player in pairs (playersInGame) do
		if not player then
			Debug.Log("이미 나간 플레이어입니다. => " .. player.Name)
			table.remove(playersInGame, i)
			continue
		end

		local character = player.Character
		if not character then
			Debug.Assert(false, "플레이어의 캐릭터가 없습니다. 게임에서 제외됩니다. => " .. player.Name)
			table.remove(playersInGame, i)
			continue
		end

		-- 스폰 포인트로 텔레포트
		self:TeleportPlayerToSpawnPoint(character, spawnPointList[i], mapCenterPosition)
	end
end

return MapController
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d3</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="26">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script1</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{B2BCD3D0-3430-4073-9D71-EF35C7E35485}</string>
				<ProtectedString name="Source"><![CDATA[local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))

local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage



function TestFunction()

	task.desynchronize()

	debug.profilebegin("Start!")
	for i = 1, 1000000 do
		ServerStorage.a = 1
	end
	debug.profileend()

	task.synchronize()
	for i = 1, 10000000 do
		ServerStorage.a = 2
	end

end



while wait(0.1) do
	TestFunction()
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d4</UniqueId>
			</Properties>
		</Item>
		<Item class="Script" referent="27">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script2</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{9BB10BF2-A7C7-40ED-B599-06E985D81B22}</string>
				<ProtectedString name="Source"><![CDATA[local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))

local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage



function TestFunction()

	task.desynchronize()

	debug.profilebegin("Start!")
	for i = 1, 1000000 do
		ServerStorage.a = 1
	end
	debug.profileend()

	task.synchronize()
	for i = 1, 10000000 do
		ServerStorage.a = 2
	end

end



while wait(0.1) do
	TestFunction()
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d5</UniqueId>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX625E4C562CFA41EF9D64A09FF6082B34">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">aaFromCode</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{CA5044FD-8340-41D9-88ED-609221920F4C}</string>
				<ProtectedString name="Source"></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac730002cf34</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="28">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020856</UniqueId>
		</Properties>
		<Item class="Folder" referent="29">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Maps</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d6</UniqueId>
			</Properties>
			<Item class="Model" referent="30">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<token name="LevelOfDetail">0</token>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">DesertMap</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d7</UniqueId>
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="31">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">4</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">DamageableObject</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">3</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d8</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>4</X>
							<Y>1.20000005</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
					<Item class="ModuleScript" referent="32">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ObjectModule</string>
							<string name="ScriptGuid">{271C0D9C-4D21-4CAA-A799-8C54284063FF}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}
local lifePoint = 20
local object = script.Parent

function module:TakeDamage(damage) -- boolean
	lifePoint -= damage

	print(lifePoint)
	if lifePoint <= 0 then
		object:Destroy()
	end
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208d9</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="33">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">ServerModule</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208da</UniqueId>
			</Properties>
			<Item class="Folder" referent="34">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">ObjectModule</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208db</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="35">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ObjectBase</string>
						<string name="ScriptGuid">{C4A854AF-2FFD-47C0-8C55-97EDA33C4571}</string>
						<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))
local Utility = CommonModuleFacade.Utility

local ServerStorage = game:GetService("ServerStorage")
local ServerModule = ServerStorage:WaitForChild("ServerModule")
local ServerGameDataModule = ServerModule:WaitForChild("ServerGameDataModule")
local ServerGameDataManager = require(ServerGameDataModule:WaitForChild("ServerGameDataManager"))
--[[
local ServerEnum = require(ServerModule:WaitForChild("ServerEnum"))
local GameDataType = ServerEnum.GameDataType
--]]

local Debug = CommonModuleFacade.Debug

local ObjectBase = {
	
	actions = {},
	Root = Utility.EmptyFunction,
	GetGameDataType = Utility.EmptyFunction,
	GetGameDataKey = Utility.EmptyFunction,
	GetGameData = Utility.EmptyFunction,
	
}
ObjectBase.__index = Utility.Inheritable__index
ObjectBase.__newindex = Utility.Inheritable__newindex

--[[
local root = nil
local gameDataType = nil
local gameDataKey = nil
local gameData = nil
--]]

-- local actions = {}


-- 함수 정의 ------------------------------------------------------------------------------------------------------

--[[
function ObjectBase:Initialize(objectGameDataType, objectRoot)

	if not objectRoot then
		Debug.Assert(false, "입력이 비정상입니다. GameDataType => " .. tostring(objectGameDataType))
		return	
	end

	local typSTring  = type(objectGameDataType)
	if not objectGameDataType or type(objectGameDataType) ~= "number" then
		Debug.Assert(false, "입력이 비정상입니다.")
		return	
	end


	local objectGameDataKey = objectRoot:FindFirstChild("Key")
	if not objectGameDataKey then
		Debug.Assert(false, "객체에 키 태그가 존재하지 않습니다.")
		return
	end

	objectGameDataKey = objectGameDataKey.Value

	local objectGameData = GameDataManager[objectGameDataType]:Get(objectGameDataKey)
	if not objectGameData then
		Debug.Assert(false, "데이터가 존재하지 않습니다.")
		return
	end

	self.root = objectRoot
	self.gameDataType = objectGameDataType
	self.gameDataKey = objectGameDataKey
	self.gameData = objectGameData
end
--]]

function ObjectBase:Initialize(objectGameDataType, objectRoot)
	
	if not objectRoot then
		Debug.Assert(false, "입력이 비정상입니다. GameDataType => " .. tostring(objectGameDataType))
		return	
	end

	local typSTring  = type(objectGameDataType)
	if not objectGameDataType or type(objectGameDataType) ~= "number" then
		Debug.Assert(false, "입력이 비정상입니다.")
		return	
	end


	local objectGameDataKey = objectRoot:FindFirstChild("Key")
	if not objectGameDataKey then
		Debug.Assert(false, "객체에 키 태그가 존재하지 않습니다.")
		return
	end

	objectGameDataKey = objectGameDataKey.Value

	local objectGameData = ServerGameDataManager[objectGameDataType]:Get(objectGameDataKey)
	if not objectGameData then
		Debug.Assert(false, "데이터가 존재하지 않습니다.")
		return
	end
	
	local interalData = {
		root = objectRoot,
		gameDataType = objectGameDataType,
		gameDataKey = objectGameDataKey,
		gameData = objectGameData,
	}
	
	self.Root = function()
		Debug.Assert(interalData.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
		return interalData.root
	end

	self.GetGameDataType = function()
		Debug.Assert(interalData.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
		Debug.Assert(interalData.gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
		return interalData.gameDataType
	end

	self.GetGameDataKey = function()
		Debug.Assert(interalData.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
		Debug.Assert(interalData.gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
		Debug.Assert(interalData.gameDataKey, "GameDataKey가 존재하지 않습니다. 초기화 해주세요.")
		return interalData.gameDataKey
	end

	self.GetGameData = function()
		Debug.Assert(interalData.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
		Debug.Assert(interalData.gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
		Debug.Assert(interalData.gameData, "GameData가 존재하지 않습니다. 초기화 해주세요.")
		return interalData.gameData
	end
end

--[[
function ObjectBase:Initialize__(objectGameDataType, objectRoot)
	
	-- Clone하면 두 번 호출될 수 있음
	if root then
		Debug.Log("재초기화 GameDataType => " .. tostring(gameDataType))
		--return	
	end
	
	if not objectRoot then
		Debug.Assert(false, "입력이 비정상입니다. GameDataType => " .. tostring(gameDataType))
		return	
	end
	
	local typSTring  = type(objectGameDataType)
	if not objectGameDataType or type(objectGameDataType) ~= "number" then
		Debug.Assert(false, "입력이 비정상입니다.")
		return	
	end
	
	
	local objectGameDataKey = objectRoot:FindFirstChild("Key")
	if not objectGameDataKey then
		Debug.Assert(false, "객체에 키 태그가 존재하지 않습니다.")
		return
	end
	
	objectGameDataKey = objectGameDataKey.Value
	
	local objectGameData = GameDataManager[objectGameDataType]:Get(objectGameDataKey)
	if not objectGameData then
		Debug.Assert(false, "데이터가 존재하지 않습니다.")
		return
	end
	
	root = objectRoot
	gameDataType = objectGameDataType
	gameDataKey = objectGameDataKey
	gameData = objectGameData
	
	
end

function ObjectBase:Root()
	Debug.Assert(self.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	return self.root
end

function ObjectBase:GetGameDataType()
	Debug.Assert(self.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(self.gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
	return self.gameDataType
end

function ObjectBase:GetGameDataKey()

	Debug.Assert(self.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(self.gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(self.gameDataKey, "GameDataKey가 존재하지 않습니다. 초기화 해주세요.")
	return self.gameDataKey
end

function ObjectBase:GetGameData()
	Debug.Assert(self.root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(self.gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(self.gameData, "GameData가 존재하지 않습니다. 초기화 해주세요.")
	return self.gameData
end
--]]
--[[
function ObjectBase.Root()
	Debug.Assert(root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	return root
end

function ObjectBase.GetGameDataType()
	Debug.Assert(root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
	return gameDataType
end

function ObjectBase.GetGameDataKey()

	Debug.Assert(root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(gameDataKey, "GameDataKey가 존재하지 않습니다. 초기화 해주세요.")
	return gameDataKey
end

function ObjectBase.GetGameData()
	Debug.Assert(root, "ObjectRoot가 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(gameDataType, "GameDataType이 존재하지 않습니다. 초기화 해주세요.")
	Debug.Assert(gameData, "GameData가 존재하지 않습니다. 초기화 해주세요.")
	return gameData
end
--]]

function ObjectBase:BindAction(action)
	
	local typeString = type(action)
	
	if typeString ~= "function" then
		Debug.Assert(false, tostring(action) .. " is not function")
		return
	end
	
	local actionName = tostring(action)
	
	self.actions[actionName] = action
end

function ObjectBase:UnbindActions()
	
	self.actions = {}
	
end

function ObjectBase:UnbindAction(action)
	
	local typeString = type(action)

	if typeString ~= "function" then
		Debug.Assert(false, tostring(action) .. " is not function")
		return
	end
	
	local actionName = tostring(action)
	self.actions[actionName] = nil
	
end

function ObjectBase:ExecuteActions(...)
	
	for --[[actionName--]] _, action in pairs(self.actions) do
		action(...)
	end
	
end

--[[
function ObjectBase.ExecuteAction(action, ...)
	
	local actionName = tostring(action)
	
	if actions[actionName]  then
		actions[actionName](...)
	end
	
end
--]]

-- 반환 코드 ------------------------------------------------------------------------------------------------------

return ObjectBase
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208dc</UniqueId>
					</Properties>
				</Item>
				<Item class="Folder" referent="36">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">ToolModule</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208dd</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="37">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CopyTest</string>
							<string name="ScriptGuid">{4DDE41F6-5D86-4AEE-ADB8-FD50EC53F562}</string>
							<ProtectedString name="Source"><![CDATA[local module = {b = 1}

local a = 0

function module:Set(input)
	
	a = input
	self.b = input
end

function module:Print()

	print("a => " .. tostring(a))
	print("b => " .. tostring(self.b))
	
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208de</UniqueId>
						</Properties>
					</Item>
					<Item class="Script" referent="38">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CopyTestScript</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{3CFABF38-0402-4556-A1F6-17FBDF36FBCE}</string>
							<ProtectedString name="Source"><![CDATA[local parent = script.Parent

local name = parent.Name


while true do
	wait(1)
	print("name => " .. name)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208df</UniqueId>
						</Properties>
					</Item>
					<Item class="Script" referent="39">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Damager</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{CF2EFF51-14A0-4335-821B-404B21A37DE0}</string>
							<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------

local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))
local Utility = ServerModuleFacade.Utility
local Debug = ServerModuleFacade.Debug
local ServerConstant = ServerModuleFacade.ServerConstant
local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage

local GameDataType = ServerModuleFacade.ServerEnum.GameDataType

local ToolBase = Utility.DeepCopy(require(ServerModuleFacade.ToolModule:WaitForChild("ToolBase")))
local Debris = game:GetService("Debris")

local Tool = script.Parent
local Anim1 = Tool.anim1
local isAttacking = false

ToolBase:InitializeAll(GameDataType.Tool, Tool)

-- 함수 정의 ------------------------------------------------------------------------------------------------------

function CanAttack(otherPart)
	
	if not otherPart then
		Debug.Assert(false, "대상이 존재하지 않습니다.")
		return false
	end
	
	local otherModel = otherPart.Parent
	if not otherModel then
		Debug.Assert(false, "모델이 존재하지 않습니다.")
		return false
	end
	
	if not Tool then
		Debug.Assert(false, "도구가 없습니다.")
		return false
	end
	
	local toolParent = Tool.Parent
	local toolParentClassName = toolParent.ClassName
	if not toolParentClassName 
		or toolParentClassName == "Workspace" 		-- 필드에 존재
		or toolParentClassName == "Backpack" then	-- 가방에 존재
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	-- 자기자신인 경우
	if toolParent == otherModel then
		return false
	end
	
	return true
	
end

function CalcDamage(attackerCharacter, attackeeCharacter)
	
	local attackerSTR = 0
	local attackeeDEF = 0
	
	-- ==== 캐릭터 계산 ====
	local attackerCharacterGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Character)
	local attackeeCharacterGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Character)
	
	-- 캐릭터 공격 데이터
	if not attackerCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackerCharacter.Name)
	else
		attackerSTR += attackerCharacterGameData.STR
	end
	
	-- 캐릭터 방어 데이터
	if not attackeeCharacterGameData then
		Debug.Assert(false, "캐릭터 정보가 없습니다." .. attackeeCharacter.Name)
	else
		attackeeDEF += attackeeCharacterGameData.DEF
	end
	
	-- ==== 도구 계산 =====
	local attackerToolGameData = ServerGlobalStorage:GetGameData(attackerCharacter, GameDataType.Tool)
	local attackeeToolGameData = ServerGlobalStorage:GetGameData(attackeeCharacter, GameDataType.Tool)
	
	-- 도구 공격 데이터
	if attackerToolGameData and attackerToolGameData.STR then
		attackerSTR += attackerToolGameData.STR
	end
	-- 도구 방어 데이터
	if attackeeToolGameData and attackeeToolGameData.DEF then
		attackeeDEF += attackeeToolGameData.DEF
	end
	
	
	local finalDamage = ServerConstant.DefaultAttackPoint + (attackerSTR * ServerConstant.DefaultSTRFactor) - attackeeDEF
	
	finalDamage = math.clamp(finalDamage, 0, 100)
	
	return finalDamage
	
end

function AttackCharacter(attackerCharacter, attackeeCharacter)

	local damage = CalcDamage(attackerCharacter, attackeeCharacter)
	Debug.Log("Damage : ".. tostring(damage))
	if damage == 0 then
		return
	end

	local attackeeCharacterHumanoid = attackeeCharacter:FindFirstChild("Humanoid")
	if not attackeeCharacterHumanoid then
		Debug.Assert(false, "Humanoid가 없습니다.")
		return
	end

	attackeeCharacterHumanoid:TakeDamage(damage)
	
end

function Attack(attackeePart)
	
	
	if CanAttack(attackeePart) == false then
		--Debug.Assert(false, "공격할 수 없습니다.")
		return
	end
	
	
	local attackeePlayer = game.Players:GetPlayerFromCharacter(attackeePart.Parent)
	print(attackeePlayer)
	print(attackeePart)
	print(attackeePart.Parent)
	if not attackeePlayer then
		-- 추가해야한다.
		Debug.Log("플레이어가 아닙니다.")
	else
		local attackerCharacter = Tool.Parent
		local attackeeCharacter = attackeePart.Parent
		AttackCharacter(attackerCharacter, attackeeCharacter)
	end
	
	
--[[
	local attackerTag = Instance.new("ObjectValue")
	attackerTag.Name = "AttackerTag"
	attackerTag.Value = attackerPlayer
	attackerTag.Parent = attackeeHumanoid
	Debris:AddItem(attackerTag, 3.5)
	--]]
end


function onTouched(otherPart)

	if isAttacking == false then return end
	isAttacking = false
	
	Attack(otherPart)
	
	--[[
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end

		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end

	target:TakeDamage(damage)
	--]]
end


function onActivated()

	--Debug.Assert(false, ToolBase:GetGameDataKey())
	isAttacking = true
	local humanoid = Tool.Parent:FindFirstChild("Humanoid")
	local anim1Track = humanoid:LoadAnimation(Anim1)
	anim1Track:Play()

	anim1Track.Stopped:Connect(function() isAttacking = false end)

	--humanoid:TakeDamage(50)
end


-- 이벤트 바인드
Tool.Activated:Connect(onActivated)
Tool.Attacker.Touched:Connect(onTouched)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e0</UniqueId>
						</Properties>
					</Item>
					<Item class="Script" referent="40">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Interactor</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{9D2D3DD2-0557-41B7-8860-105467375898}</string>
							<ProtectedString name="Source"><![CDATA[local Interactor = {}

local ObjectBase = require(script.Parent:WaitForChild("ObjectBase"))

return Interactor
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e1</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="41">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ToolBase</string>
							<string name="ScriptGuid">{8BAB0E25-E8F6-4C8C-8D93-CBCCE76DDD0C}</string>
							<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------
local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))

local Utility = ServerModuleFacade.Utility
local ServerEnum = ServerModuleFacade.ServerEnum
local GameDataType = ServerEnum.GameDataType

local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage

local GameDataManager = ServerModuleFacade.GameDataManager
local Debug = ServerModuleFacade.Debug


local ToolBase = {}
ToolBase.__index = Utility.Inheritable__index
ToolBase.__newindex = Utility.Inheritable__newindex


-- 함수 정의 ------------------------------------------------------------------------------------------------------

-- Tool에 붙은 데이터들을 플레이어에게 적용하기

function onEquipped(toolBase)

	local tool = toolBase.Root()
	--local temp = getmetatable(toolBase)
	--local temp2 = temp.GetGameDataKey()
	--local temp = ServerGlobalStorage
	
	-- 캐릭터가 장착중인 상태 -- Character의 Parent는 Workspace이다 주의해야한다.
	-- tool =(parent)> Character
	local character = tool.Parent
	ServerGlobalStorage:AddGameData(character, toolBase.GetGameData())
		
end


function onUnequipped(toolBase)
	
	local tool = toolBase.Root()
	local temp = getmetatable(toolBase)
	
	--Backpack에 존재 
	-- tool =(parent)> Backpack =(parent)> Player > Character
	local character = tool.Parent.Parent.Character
	ServerGlobalStorage:RemoveGameData(character, toolBase.GetGameDataType())
	
end

function ToolBase:InitializeAll(gameDataType, tool)
	
	self:Initialize(gameDataType, tool)
	
	tool.Equipped:Connect(function() onEquipped(self) end)
	tool.Unequipped:Connect(function() onUnequipped(self) end)
	
end


-- 반환 코드 ------------------------------------------------------------------------------------------------------

setmetatable(ToolBase, Utility.DeepCopy(require(ServerModuleFacade.ObjectModule:WaitForChild("ObjectBase"))))
return ToolBase
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e2</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="42">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">WorldInteractorModule</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e3</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="43">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">WorldInteractorBase</string>
							<string name="ScriptGuid">{B423AE33-FDB0-4A15-BE11-6D94C9396B9B}</string>
							<ProtectedString name="Source"><![CDATA[-- 로컬 변수 정의, 바인드 --------------------------------------------------------------------------------------------
local ServerStorage = game:GetService("ServerStorage")
local ServerModuleFacade = require(ServerStorage:WaitForChild("ServerModuleFacade"))

local Utility = ServerModuleFacade.Utility
local ServerEnum = ServerModuleFacade.ServerEnum
local GameDataType = ServerEnum.GameDataType

local ServerGlobalStorage = ServerModuleFacade.ServerGlobalStorage

local GameDataManager = ServerModuleFacade.GameDataManager
local Debug = ServerModuleFacade.Debug


local WorldInteractorBase = {}
WorldInteractorBase.__index = Utility.Inheritable__index
WorldInteractorBase.__newindex = Utility.Inheritable__newindex


-- 함수 정의 ------------------------------------------------------------------------------------------------------

-- Tool에 붙은 데이터들을 플레이어에게 적용하기

function onEquipped(toolBase)

	local tool = toolBase.Root()
	--local temp = getmetatable(toolBase)
	--local temp2 = temp.GetGameDataKey()
	--local temp = ServerGlobalStorage

	-- 캐릭터가 장착중인 상태 -- Character의 Parent는 Workspace이다 주의해야한다.
	-- tool =(parent)> Character
	local character = tool.Parent
	ServerGlobalStorage:AddGameData(character, toolBase.GetGameData())

end


function onUnequipped(toolBase)

	local tool = toolBase.Root()
	local temp = getmetatable(toolBase)

	--Backpack에 존재 
	-- tool =(parent)> Backpack =(parent)> Player > Character
	local character = tool.Parent.Parent.Character
	ServerGlobalStorage:RemoveGameData(character, toolBase.GetGameDataType())

end

function onDestroying(worldInteractorBase)
	
	local worldInteractor = worldInteractorBase.Root()
	local worldInteractorData = worldInteractorBase.GetGameData()
	
end

function WorldInteractorBase:InitializeAll(gameDataType, worldInteractor)
	self:Initialize(gameDataType, worldInteractor)
	worldInteractor.Destroying:Connect(function() onDestroying(self) end)
end


-- 반환 코드 ------------------------------------------------------------------------------------------------------

setmetatable(WorldInteractorBase, Utility.DeepCopy(require(ServerModuleFacade.ObjectModule:WaitForChild("ObjectBase"))))
return WorldInteractorBase
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e4</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="44">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ServerConstant</string>
					<string name="ScriptGuid">{427EB2C1-387A-49F4-B7EA-1BA50D9E0F3C}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))
local Utility = CommonModuleFacade.Utility
local CommonConstant = CommonModuleFacade.CommonConstant


local ServerConstant = {
	DefaultAttackPoint = 10,
	DefaultSTRFactor = 1.2,
	IsTestMode = true
}

ServerConstant.__index = Utility.Inheritable__index
ServerConstant.__newindex = Utility.Inheritable__newindex

setmetatable(ServerConstant, CommonConstant)

return ServerConstant
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e5</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="45">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ServerEnum</string>
					<string name="ScriptGuid">{64E520F9-B37C-4506-B666-732641E31E18}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))
local Utility = CommonModuleFacade.Utility
local CommonEnum = CommonModuleFacade.CommonEnum


local ServerEnum = {


}

ServerEnum.__index = Utility.Inheritable__index
ServerEnum.__newindex = Utility.Inheritable__newindex

setmetatable(ServerEnum, CommonEnum)

return ServerEnum
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e6</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="46">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">ServerGameDataModule</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e7</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="47">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ServerGameDataManager</string>
						<string name="ScriptGuid">{44E25235-E10E-4D46-890F-9735313AA102}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))

local CommonEnum = CommonModuleFacade.CommonEnum
local GameDataType = CommonEnum.GameDataType

local Utility = CommonModuleFacade.Utility
local CommonGameDataManager = CommonModuleFacade.CommonGameDataManager


local ServerGameDataManager = {
	[GameDataType.Character] = require(script:WaitForChild("CharacterGameData")),
	[GameDataType.WorldInteractor] = require(script:WaitForChild("WorldInteractorGameData"))
}

ServerGameDataManager.__index = Utility.Inheritable__index
ServerGameDataManager.__newindex = Utility.Inheritable__newindex
setmetatable(ServerGameDataManager, CommonGameDataManager)

return ServerGameDataManager
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e8</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="48">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CharacterGameData</string>
							<string name="ScriptGuid">{FF7E5FE6-DA87-4212-BD7E-A7428B68F2E2}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType

local Utility = require(CommonModule:WaitForChild("Utility"))
local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local GameDataBase = Utility.DeepCopy(require(CommonGameDataModule:WaitForChild("GameDataBase")))


local CharacterGameData = setmetatable({Name = "CharacterGameData"}, GameDataBase)
CharacterGameData:Initialize(GameDataType.Character)


--[[
HP : 체력
MP : 마력
STR : 공격력
DEF : 방어력
HIT : 명중
AttackSpeed : 공격속도
Dodge : 회피
Block : 블록
Critical : 크리티컬
Move : 이동력
Sight : 시야
--]]


--[[ 기본 	--]] CharacterGameData:InsertData(1, {STR = 10, DEF = 10, Move = 10, AttackSpeed = 10, Skill = ""})
--[[ 성장	--]] CharacterGameData:InsertData(2, {STR = 50, DEF = 50, Move = 50, AttackSpeed = 50, Skill = ""})

return setmetatable({}, CharacterGameData)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208e9</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="49">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">WorldInteractorGameData</string>
							<string name="ScriptGuid">{42A22240-7CF1-4647-9C7A-02300E35112B}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType

local Utility = require(CommonModule:WaitForChild("Utility"))
local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local GameDataBase = Utility.DeepCopy(require(CommonGameDataModule:WaitForChild("GameDataBase")))


local WorldInteractorGameData = setmetatable({Name = "WorldInteractorGameData"}, GameDataBase)
WorldInteractorGameData:Initialize(GameDataType.WorldInteractor)


--[[ 검 드롭		--]] WorldInteractorGameData:InsertData(1, {DropToolGameDataKey = 2})
--[[ 도끼 상자   --]] WorldInteractorGameData:InsertData(2, {DropToolGameDataKey = 3})

return setmetatable({}, WorldInteractorGameData)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ea</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="50">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ServerGlobalStorage</string>
					<string name="ScriptGuid">{DC02FFDE-5B72-43C0-A07C-1739404590A0}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))
local Debug = CommonModuleFacade.Debug
local Utility = CommonModuleFacade.Utility
local CommonGlobalStorage = CommonModuleFacade.CommonGlobalStorage

local ServerStorage = game:GetService("ServerStorage")
local ServerModule = ServerStorage:WaitForChild("ServerModule")
local ServerEnum = require(ServerModule:WaitForChild("ServerEnum"))
local GameDataType = ServerEnum.GameDataType

local ServerGlobalStorage = {}

-- static 변수 반드시 싱글톤으로 사용해야 한다.
local Characters = {}


function ServerGlobalStorage:CheckCharacter(character)
	if Characters[character] then
		return true
	end
	return false
end

function ServerGlobalStorage:AddCharacter(character)
	
	if self:CheckCharacter(character) then
		Debug.Assert(false, "두 번 추가하려고 합니다.")
		return
	end
	
	Characters[character] = {}
	
end

function ServerGlobalStorage:RemoveCharacter(character)
	
	Characters[character] = nil
	
end

function ServerGlobalStorage:GetGameData(character, gameDataType)
	
	if not self:CheckCharacter(character) then
		Debug.Assert(false, "캐릭터가 없습니다.")
		return nil
	end
	
	if not Characters[character][gameDataType] then
		Debug.Print("게임 데이터 type(" .. tostring(gameDataType) .. ")가 초기화되지 않았습니다. => ".. character.Name)
		return nil
	end
	
	return Characters[character][gameDataType]
	
end


function ServerGlobalStorage:AddGameData(character, gameData)
	
	if not gameData then
		Debug.Assert(false, "입력으로 들어온 gameData가 비정상입니다.")
		return false
	end
	
	if not self:CheckCharacter(character) then
		Debug.Assert(false, "캐릭터가 없습니다.")
		return false
	end
	
	local gameDataType = gameData:GetGameDataType()
	Characters[character][gameDataType] = gameData
end

function ServerGlobalStorage:RemoveGameData(character, gameDataType)
	
	if not self:CheckCharacter(character) then
		Debug.Assert(false, "캐릭터가 없습니다.")
		return nil
	end
	
	Characters[character][gameDataType] = nil
	
end

ServerGlobalStorage.__index = Utility.Inheritable__index
ServerGlobalStorage.__newindex = Utility.Inheritable__newindex

setmetatable(ServerGlobalStorage, CommonGlobalStorage)


return ServerGlobalStorage
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208eb</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="51">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ServerModuleFacade</string>
				<string name="ScriptGuid">{404556F3-EC86-4AB2-B5DF-19FD52B0BB3B}</string>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModuleFacade = require(ReplicatedStorage:WaitForChild("CommonModuleFacade"))

local ServerStorage = game:GetService("ServerStorage")
local ServerModule = ServerStorage:WaitForChild("ServerModule")

-- 서버 상수
local ServerConstant = require(ServerModule:WaitForChild("ServerConstant"))
local ServerEnum = require(ServerModule:WaitForChild("ServerEnum"))

-- 서버 전역변수
local ServerGlobalStorage = require(ServerModule:WaitForChild("ServerGlobalStorage"))

-- 게임 데이터 매니저
local ServerGameDataModule = ServerModule:WaitForChild("ServerGameDataModule")
local ServerGameDataManager = require(ServerGameDataModule:WaitForChild("ServerGameDataManager"))

-- 오브젝트 모듈
local ObjectModule = ServerModule:WaitForChild("ObjectModule")
local ToolModule = ObjectModule:WaitForChild("ToolModule")
local VehicleModule = ObjectModule:WaitForChild("VehicleModule")
local WorldInteractorModule = ObjectModule:WaitForChild("WorldInteractorModule")


local ServerModuleFacade = {
	ServerModule = ServerModule,
	ServerConstant = ServerConstant,
	ServerEnum = ServerEnum,
	ServerGlobalStorage = ServerGlobalStorage,
	ServerGameDataManager = ServerGameDataManager,
	ObjectModule = ObjectModule,
	ToolModule = ToolModule,
	VehicleModule = VehicleModule,
	WorldInteractorModule = WorldInteractorModule
}

setmetatable(ServerModuleFacade, CommonModuleFacade)
ServerModuleFacade.__index = ServerModuleFacade.Utility.Inheritable__index

return ServerModuleFacade
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ec</UniqueId>
			</Properties>
		</Item>
		<Item class="Folder" referent="52">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">TestCode</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ed</UniqueId>
			</Properties>
			<Item class="Script" referent="53">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Loader</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{97F9C1EB-9B88-4FD7-AB7C-4B6A8FDBED5F}</string>
					<ProtectedString name="Source"><![CDATA[local SubClassCDO = require(script.SubClass)
local SuperClassCDO = require(script.SuperClass)


local subClassObject = SubClassCDO.Clone()
subClassObject.PrintDerived(subClassObject)

-- SuperClass에 있는 변수
print("value1 is in SuperClass public => " .. tostring(subClassObject.value1))
print("value2 is in SuperClass private => " .. tostring(subClassObject.value2))


-- SubClass에 있는 변수
print("value3 is in SuperClass public => " .. tostring(subClassObject.value3))
print("value4 is in SuperClass private => " .. tostring(subClassObject.value4))


local temp1 = subClassObject:CastByCDO(SuperClassCDO)
print("CastByCDO => SuperClassCDO => " .. temp1.GetClassTypeForInstance())
print("RealType(ref from reflection data) =>" .. temp1:GetType())

local temp2 = subClassObject:CastByType(SuperClassCDO:GetClassTypeForCDO())
print("CastByType => SuperClass Type => " .. temp2.GetClassTypeForInstance())
print("RealType(ref from reflection data) => " .. temp2:GetType())


local temp3 = subClassObject:CastByType("ClassBase")
print("CastByType => ClassBase Type => " .. temp3.GetClassTypeForInstance())
print("RealType(ref from reflection data) => " .. temp3:GetType())

-- SuperClass에 있는 함수
subClassObject.PrintBase(subClassObject)
print("GetPrivateValue2 => ".. tostring(subClassObject:GetPrivateValue2()))


local b = 2
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ee</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="54">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClassBase</string>
						<string name="ScriptGuid">{3027E4A5-AAF3-4243-9BAE-F3C7C8DEACF8}</string>
						<ProtectedString name="Source"><![CDATA[function AccessProtection__index(table, key)

	--print("AccessProtection__index => " .. tostring(key))
	--print(table)
	local classBody = getmetatable(table)
	
	-- 있으면 반환한다.
	local value = rawget(classBody.public, key)
	if value then
		return value
	end
	
	-- 부모 클래스를 확인한다.
	return classBody[key]
end

function AccessProtection__newindex(table, key, value)

	--print("AccessProtection__newindex => " .. tostring(key))
	--print(table)
	
	local alreadyExistKey = table[key] -- 부모 클래스에서 찾아보는 과정
	if alreadyExistKey then
		alreadyExistKey = value
	else -- 찾아보고 없으면 그냥 테이블에 할당한다.
		rawset(table, key, value)
	end
	
end


local ClassBase = {
	
	public = {
	},
	
	private = {
		reflectionData = {type = "ClassBase"},		
	},
	
	IsClassBase = true
}

ClassBase.__index = AccessProtection__index
ClassBase.__newindex = AccessProtection__newindex


function IsEmpty(target)
	
	local rv = rawget(target, "IsClassBase")
	if rv  then
		return true
	end

	return false
end

function CastToRawClassBase(target)
	
	if not target then
		return nil
	end
	
	-- 처음부터 ClassBase가 들어올 수 없다.
	local fromClassBody = getmetatable(target)
	if not fromClassBody then return nil end
	
	if IsEmpty(fromClassBody) then
		return fromClassBody
	end
	
	return CastToRawClassBase(fromClassBody)
end


function DeepCopyDetail(original)

	local originalType = type(original)
	local copy = {}

	if originalType == 'table' then

		for key, value in next, original, nil do
			copy[DeepCopyDetail(key)] = DeepCopyDetail(value)
		end
		setmetatable(copy, DeepCopyDetail(getmetatable(original)))

	else -- number, string, boolean, etc
		copy = original
	end

	return copy
	
end

function ClassBase.public.GetClassTypeForInstance()
	return "ClassBase"
end

function ClassBase.public:GetClassTypeForCDO()
	return self.public.GetClassTypeForInstance()
end

function ClassBase.public.DeepCopy(target)
	return DeepCopyDetail(target)
end

function ClassBase.public:CastByType(toClassType)

	local classType = self.GetClassTypeForInstance()

	if toClassType == classType then
		return self
	end

	local fromClassBody = getmetatable(self)
	if not fromClassBody or IsEmpty(fromClassBody) then return nil end

	return fromClassBody:CastByType(toClassType)
end

function ClassBase.public:CastByCDO(toClassBody)

	if not toClassBody or IsEmpty(toClassBody) then
		return nil
	end

	return self:CastByType(toClassBody:GetClassTypeForCDO())
end

function ClassBase.public:IsAByType(toClassType)

	local rv = self:CastByType(toClassType)
	if rv  then
		return true
	end

	return false

end

function ClassBase.public:IsAByCDO(toClassBody)

	local rv = self:CastByCDO(toClassBody)
	if rv  then
		return true
	end

	return false
end

function ClassBase.public:IsItselfByType(toClassType)

	if not toClassType then
		return false
	end

	-- 다른 클래스의 GetType이 호출되지 않도록 하기 위해 가장 클래스를 맨앞으로 가져온다.
	local fromClassBody = getmetatable(self)
	if not fromClassBody or IsEmpty(fromClassBody) then return false end

	local fromClassType = fromClassBody.GetClassTypeForInstance()

	if toClassType == fromClassType then
		return true
	end

	return false

end

function ClassBase.public:IsItselfByCDO(toClassBody)

	if not toClassBody or IsEmpty(toClassBody)  then
		return false
	end
	
	return self:IsItselfByType(toClassBody:GetClassTypeForCDO())

end

function ClassBase.public:GetThisByCDO(toClassBody)
	
	local thisInstance = self:CastByCDO(toClassBody)
	
	if not thisInstance then
		-- 발생하면 원칙을 잘 지키지 않고 코드를 작성한 경우다.
		return nil
	end
	
	-- 이렇게 하면 해당 클래스에서 접근 가능하다. 대신 public, private 과 같은 이름을 앞에 붙여줘야 한다.
	local this = getmetatable(thisInstance)
	
	return this
end

function ClassBase.public:SetType(inputString)

	local typeString = type(inputString)
	if typeString ~= "string" then
		return
	end

	local this = CastToRawClassBase(self)

	-- 이 메소드에 들어왔기 때문에 무조건 캐스팅이 보장된다.
	--if not this then return end

	this.private.reflectionData.type = inputString
end

function ClassBase.public:GetType()
	
	local this = CastToRawClassBase(self)
	
	return this.private.reflectionData.type
end


return ClassBase 
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ef</UniqueId>
					</Properties>
				</Item>
				<Item class="Script" referent="55">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Script6</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{03F908AA-B058-4F34-A3A4-162B2D0BA5CF}</string>
						<ProtectedString name="Source"><![CDATA[-- 인스턴스로 만들 때 독립적인 인스턴스를 CDO에서 복사하여 생성하여야 한다.

-- local ClassBaseInstance = setmetatable({}, ClassBase)

--local AccessType = {P1 = 1, P2 = 2, P3 = 3}

--[[
local __indexFunction = function(table, key)
	print("table =>")
	print(table)
	local matetable = getmetatable(table)
	print("matetable =>")
	print(matetable)
	
	local rv = rawget(matetable.public, key)
	
	if rv then
		return rv
	end
	
	return matetable[key]
end

local test1 = {public = {v1 = 1}}
test1.__index = __indexFunction
local test2 = setmetatable({public = {v2 = 2}}, test1)
test2.__index = __indexFunction
local test3 = setmetatable({public = {v3 = 3}}, test2)
test3.__index = __indexFunction

local v1Value = test3.v1
local fdnskalf

--]]

--[[


local ClassBase = require(script.ClassBase)


-- SuperClass 구현

local SuperClassCDO = {
	
	public = {
		value1 = 1,
		GetClassTypeForInstance = function() return "SuperClass" end
	},
	private = {
		value2 = 2}
}

SuperClassCDO.__index = ClassBase.__index
SuperClassCDO.__newindex = ClassBase.__newindex


local temp3 = getmetatable(SuperClassCDO)

local a  =2

-- 상속 받은 다른 클래스에서 접근 지정자에 따라 접근할 수 있도록 해준다.

function SuperClassCDO.Clone()
	
	local baseCopy = SuperClassCDO.DeepCopy(SuperClassCDO)
	return setmetatable({}, baseCopy)
	
end

function SuperClassCDO.public:GetPrivateValue2()
	
	return SuperClassCDO.private.value2
	
end


function SuperClassCDO.public:PrintBase()

	local this = self:GetThisByCDO(SuperClassCDO)
	
	print("SuperClassCDO.public:PrintBase() => ")
	print(this.public.value1)
	print(this.private.value2)
	
end

-- 마지막에 연결해야한다.
setmetatable(SuperClassCDO, ClassBase.public.DeepCopy(ClassBase))
SuperClassCDO.SetType(SuperClassCDO, "SuperClass")

-- SubClass 구현

local SubClassCDO = {

	public = {
		value3 = 3,
		GetClassTypeForInstance = function() return "SubClass" end
	},
	private = {
		value4 = 4
	}
}


local temp1 = getmetatable(SubClassCDO)
local temp2 = getmetatable(temp1)

SubClassCDO.__index = ClassBase.__index
SubClassCDO.__newindex = ClassBase.__newindex




function SubClassCDO.Clone()

	local derivedCopy = SubClassCDO.DeepCopy(SubClassCDO)
	return setmetatable({}, derivedCopy)

end

function SubClassCDO.public:PrintDerived()
	
	local this = self:GetThisByCDO(SubClassCDO)
	
	print("SubClassCDO.public:PrintDerived() =>")
	print(this.public.value3)
	print(this.private.value4)
	
	this.private.PrintPrivateDerived(self)
	this:PrintBase(self)
	
end


function SubClassCDO.private:PrintPrivateDerived()

	local this = self:GetThisByCDO(SubClassCDO)

	print("SubClassCDO.private:PrintPrivateDerived() =>")

end

-- 마지막에 연결해야한다.
setmetatable(SubClassCDO, SuperClassCDO.DeepCopy(SuperClassCDO))
SubClassCDO:SetType("SubClass")


local SubClassObject = SubClassCDO.Clone()
SubClassObject.PrintDerived(SubClassObject)

-- SuperClass에 있는 함수
SubClassObject.PrintBase(SubClassObject)
local a = SubClassObject:GetPrivateValue2()


local b = 2

--]]]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f0</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="56">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SubClass</string>
						<string name="ScriptGuid">{683C05AB-145B-413A-8391-0EF155321F09}</string>
						<ProtectedString name="Source"><![CDATA[local root = script.Parent

local SuperClassCDO = require(root.SuperClass)

-- SubClass 구현

local SubClassCDO = {

	public = {
		value3 = 3,
		GetClassTypeForInstance = function() return "SubClass" end
	},
	private = {
		value4 = 4
	}
}


SubClassCDO.__index = SuperClassCDO.__index
SubClassCDO.__newindex = SuperClassCDO.__newindex


function SubClassCDO.Clone()

	local derivedCopy = SubClassCDO.DeepCopy(SubClassCDO)
	return setmetatable({}, derivedCopy)

end

function SubClassCDO.public:PrintDerived()

	local this = self:GetThisByCDO(SubClassCDO)

	print("SubClassCDO.public:PrintDerived() => " .. tostring(this.public.value3) .. tostring(this.private.value4))

	this.private.PrintPrivateDerived(self)
	this:PrintBase(self)

end


function SubClassCDO.private:PrintPrivateDerived()

	local this = self:GetThisByCDO(SubClassCDO)

	print("SubClassCDO.private:PrintPrivateDerived() =>")

end

-- 같은 이름의 함수를 허용하려면 이 위로 정의한다.

setmetatable(SubClassCDO, SuperClassCDO.DeepCopy(SuperClassCDO))
SubClassCDO:SetType("SubClass")

-- 같은 이름의 함수를 완전히 덮어쓰려면 이 아래에 정의한다. -- 오버라이딩과 비슷하게 동작한다.


return SubClassCDO]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f1</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="57">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SuperClass</string>
						<string name="ScriptGuid">{563470F4-CD84-4C76-845C-21EDA6DF8F0C}</string>
						<ProtectedString name="Source"><![CDATA[local root = script.Parent

local ClassBase = require(root.ClassBase)

-- SuperClass 구현

local SuperClassCDO = {

	public = {
		value1 = 1,
		GetClassTypeForInstance = function() return "SuperClass" end
	},
	private = {
		value2 = 2}
}

SuperClassCDO.__index = ClassBase.__index
SuperClassCDO.__newindex = ClassBase.__newindex


-- 상속 받은 다른 클래스에서 접근 지정자에 따라 접근할 수 있도록 해준다.

function SuperClassCDO.Clone()

	local baseCopy = SuperClassCDO.DeepCopy(SuperClassCDO)
	return setmetatable({}, baseCopy)

end

function SuperClassCDO.public:GetPrivateValue2()

	return SuperClassCDO.private.value2

end


function SuperClassCDO.public:PrintBase()

	local this = self:GetThisByCDO(SuperClassCDO)
	print("SuperClassCDO.public:PrintBase() => " .. tostring(this.public.value1) .. tostring(this.private.value2))

end

-- 같은 이름의 함수를 허용하려면 이 위로 정의한다.

setmetatable(SuperClassCDO, ClassBase.public.DeepCopy(ClassBase))
SuperClassCDO.SetType(SuperClassCDO, "SuperClass")

-- 같은 이름의 함수를 완전히 덮어쓰려면 이 아래에 정의한다. -- 오버라이딩과 비슷하게 동작한다.


return SuperClassCDO]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f2</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="58">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Tools</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f3</UniqueId>
			</Properties>
			<Item class="Tool" referent="59">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="CanBeDropped">true</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="ManualActivationOnly">false</bool>
					<string name="Name">Axe</string>
					<bool name="RequiresHandle">true</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Content name="TextureId"><null></null></Content>
					<string name="ToolTip"></string>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f4</UniqueId>
				</Properties>
				<Item class="Script" referent="60">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AxeController2</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{7B434FB3-ED6F-4E37-86D9-E2BD9A9B60B0}</string>
						<ProtectedString name="Source"><![CDATA[local tool = script.Parent

local function explode(point)
	local e = Instance.new("Explosion")
	e.DestroyJointRadiusPercent = 0 -- Make the explosion non-deadly 
	e.Position = point
	e.Parent = workspace
end

local function onActivated()
	-- Get the Humanoid that Activated the tool
	print("onActivated")
	local human = tool.Parent.Humanoid
	-- Call explode with the current point the Humanoid is targetting
	explode(tool.Parent.HumanoidRootPart.Position) 
end

tool.Activated:Connect(onActivated)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f5</UniqueId>
					</Properties>
				</Item>
				<Item class="Script" referent="61">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">WeaponController</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{912069E2-6879-4CD6-88DD-CB4BD9A87F16}</string>
						<ProtectedString name="Source"><![CDATA[-- 로컬 변수

local tool = script.Parent
local anim1 = tool.anim1
local damage = 30
local isAttacking = false
local humanoid
local target
local anim1Track


-- 이벤트 함수 정의

local function onTouched(otherPart)

	if isAttacking == false then return end

	isAttacking = false
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end

		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end

	target:TakeDamage(damage)
end


local function onActivated()

	isAttacking = true
	humanoid = tool.Parent.Humanoid
	anim1Track = humanoid:LoadAnimation(anim1)
	anim1Track:Play()

	anim1Track.Stopped:Connect(function() isAttacking = false end)
end


-- 이벤트 바인드

tool.Activated:Connect(onActivated)
tool.Attacker.Touched:Connect(onTouched)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f6</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Tool" referent="62">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="CanBeDropped">true</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="ManualActivationOnly">false</bool>
					<string name="Name">Sword</string>
					<bool name="RequiresHandle">true</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Content name="TextureId"><null></null></Content>
					<string name="ToolTip"></string>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f7</UniqueId>
				</Properties>
				<Item class="Script" referent="63">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">WeaponController</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{5FEBD74B-D469-4997-A928-9187D517B8D1}</string>
						<ProtectedString name="Source"><![CDATA[-- 로컬 변수

local tool = script.Parent
local anim1 = tool.anim1
local damage = 5
local isAttacking = false
local humanoid
local target
local anim1Track


-- 이벤트 함수 정의

local function onTouched(otherPart)
	
	if isAttacking == false then return end
	
	isAttacking = false
	target = otherPart.Parent:FindFirstChild("Humanoid")
	if target ~= nil then 
		if target.Parent == tool.Parent then return end
	else
		if not otherPart.Parent.ObjectModule then return end
	
		target = require(otherPart.Parent.ObjectModule)
		if target == nil then return end
	end
	
	target:TakeDamage(damage)
end


local function onActivated()
	
	isAttacking = true
	humanoid = tool.Parent.Humanoid
	anim1Track = humanoid:LoadAnimation(anim1)
	anim1Track:Play()
	
	anim1Track.Stopped:Connect(function() isAttacking = false end)
	
	humanoid:TakeDamage(50)
end


-- 이벤트 바인드
tool.Activated:Connect(onActivated)
tool.Attacker.Touched:Connect(onTouched)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208f8</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Part" referent="RBXF9562FC2F2814C968003409E23B6725C">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>6.39999914</X>
					<Y>0.500003994</Y>
					<Z>5.79999924</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Part</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac730002d4b8</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020857</UniqueId>
		</Properties>
		<Item class="Folder" referent="1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">CommonModule</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208b5</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CommonConstant</string>
					<string name="ScriptGuid">{09CF96FB-F853-4BB8-90FE-4817E21A8AFE}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")
local Utility = require(CommonModule:WaitForChild("Utility"))

local CommonConstant = {
	MaxQuickSlotCount = 5,
	MaxInventorySlotCount = 30,
	GuiInventorySlotCountPerLine = 5,
	GuiInventorySlotOffset = 5,
	UndefinedElementValue = false
}

CommonConstant.__index = Utility.Inheritable__index
CommonConstant.__newindex = Utility.Inheritable__newindex

return CommonConstant
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208b6</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CommonEnum</string>
					<string name="ScriptGuid">{16E46727-300C-496C-9E67-918EC1D34F7B}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")
local Utility = require(CommonModule:WaitForChild("Utility"))

local CommonEnum = {
	
	GameStateType = {
		Waiting = 1,
		Starting = 2,
		Playing = 3,
		Dead = 4,
		WaitingForFinishing = 5
	},
	
	WinnerType =  {
		Player = 0,
		NoOne_TimeIsUp = 1,
		NoOne_AllPlayersWereDead = 2,
		Ai = 3
	},
	
	GameDataType = {
		Character = 1,
		Tool = 2,
		Vehicle = 3,
		WorldInteractor = 4,
	},
	
	ToolType = {
		All = 1,
		Weapon = 2,
		Armor = 3,
		Consumable = 4
	},
	
	ArmorType = {
		Helmet = 1,
		Chestplate = 2,
		Leggings = 3,
		Boots = 4
	},
	
	StatusType = {
		Statistic = 1,
		WeaponSlot = 2,
		ArmorSlot = 3,
		Inventory = 4,
		QuickSlot = 5, -- 클라이언트 전용
	}
	
	--[[,
	
	MessageType = {
		Main = 0,
		Event = 1
	}--]]
}

CommonEnum.__index = Utility.Inheritable__index
CommonEnum.__newindex = Utility.Inheritable__newindex

return CommonEnum
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208b7</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">CommonGameDataModule</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208b8</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CommonGameDataManager</string>
						<string name="ScriptGuid">{BD631BE6-6B54-43BC-8BA2-B78ED8236F77}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType

local Utility = require(CommonModule:WaitForChild("Utility"))


local CommonGameDataManager = {
	[GameDataType.Tool] = require(script:WaitForChild("ToolGameData"))
}

CommonGameDataManager.__index = Utility.Inheritable__index
CommonGameDataManager.__newindex = Utility.Inheritable__newindex

return CommonGameDataManager
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208b9</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ToolGameData</string>
							<string name="ScriptGuid">{C145F105-BA1A-4780-A48B-7C953E633936}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType
local ToolTypeSelector = CommonEnum.ToolType
local ArmorTypeSelector = CommonEnum.ArmorType


local Utility = require(CommonModule:WaitForChild("Utility"))
local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local GameDataBase = Utility.DeepCopy(require(CommonGameDataModule:WaitForChild("GameDataBase")))


local ToolGameData = setmetatable({Name = "ToolGameData"}, GameDataBase)
ToolGameData:Initialize(GameDataType.Tool)

--[[
HP : 체력
MP : 마력
STR : 공격력
DEF : 방어력
HIT : 명중
AttackSpeed : 공격속도
Dodge : 회피
Block : 블록
Critical : 크리티컬
Move : 이동력
Sight : 시야
--]]

-- 무기 종류
--[[ 기본 무기 	--]] ToolGameData:InsertData(1, {ToolType = ToolTypeSelector.Weapon, STR = 10, DEF = 10, Move = 10, AttackSpeed = 10, Skill = ""})
--[[ 검 			--]] ToolGameData:InsertData(2, {ToolType = ToolTypeSelector.Weapon, STR = 10, DEF = 10, Move = 15, AttackSpeed = 30, Skill = ""})
--[[ 도끼		--]] ToolGameData:InsertData(3, {ToolType = ToolTypeSelector.Weapon, STR = 25, DEF = 5, Move = 1, AttackSpeed = 10, Skill = ""})


-- 방어구 종류
--[[ 기본 머리	--]] ToolGameData:InsertData(101, {ToolType = ToolTypeSelector.Weapon, ArmorType = ArmorTypeSelector.Helmet, DEF = 15})
--[[ 기본 가슴	--]] ToolGameData:InsertData(102, {ToolType = ToolTypeSelector.Weapon, ArmorType = ArmorTypeSelector.Chestplate, DEF = 30, Move = -5})
--[[ 기본 다리	--]] ToolGameData:InsertData(103, {ToolType = ToolTypeSelector.Weapon, ArmorType = ArmorTypeSelector.Leggings, DEF = 20, Move = 5})
--[[ 기본 발		--]] ToolGameData:InsertData(104, {ToolType = ToolTypeSelector.Weapon, ArmorType = ArmorTypeSelector.Boots, DEF = 10, Move = 10})



-- 소모품 종류


return setmetatable({}, ToolGameData)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208ba</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GameDataBase</string>
						<string name="ScriptGuid">{B48F3EE1-3DCE-4A48-B04D-A97B43FE4093}</string>
						<ProtectedString name="Source"><![CDATA[-- 상위 코드에서 같은 리소스에 대해 Wait 하는 경우가 생긴다. 종속성을 없애야 한다.
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))
local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType


local GameDataBase = {}
GameDataBase.__index = Utility.Inheritable__index
GameDataBase.__newindex = Utility.Immutable__newindex

-- readonly로 만들어준다.
function GameDataBase:Initialize(gameDataType)
	rawset(self, "__index", Utility.Inheritable__index)
	rawset(self, "__newindex", Utility.Immutable__newindex)
	
	if not gameDataType then
		Debug.Assert(false, "비정상적인 Enum 값입니다." .. tostring(gameDataType))
		return
	end
	GameDataBase.GetGameDataType = function() return gameDataType end
end

function GameDataBase:Get(key)
	
	local keyTypeString = type(key)
	
	if keyTypeString ~= "number" then
		Debug.Assert(false, "잘못된 키값입니다.")
		return nil
	end
	
	local value = self[key]
	
	if not value then
		Debug.Assert(false, "존재하지 않는 키값입니다. => ".. tostring(key))
		return nil
	end
	
	return value
end

function GameDataBase:InsertData(key, value)
	
	local keyTypeString = type(key)
	
	if keyTypeString ~= "number" then
		Debug.Assert(false, "정수형 키만 가질 수 있습니다.")
		return
	end
	
	if self[key] ~= nil then
		Debug.Assert(false, "중복 삽입하려고 합니다.")
		return
	end
	
	local valueTypeString = type(value)
	
	if valueTypeString ~= "table" then
		Debug.Assert(false, "잘못된 값을 삽입하려고 합니다.")
		return
	end
	
	value.GetGameDataType = GameDataBase.GetGameDataType
	value.GetKey = function() return key end
	
	setmetatable(value, {__index = function(_, prop)
		Debug.Assert(false, "해당 속성이 존재하지 않습니다.".. self.Name .. "[" ..tostring(key).. "] => " .. tostring(prop)) 
	end} )
	
	value.__index = Utility.Inheritable__index
	value.__newindex = Utility.Immutable__newindex
	
	rawset(self, key, setmetatable({}, value))
	
end


return GameDataBase
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208bb</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CommonGlobalStorage</string>
					<string name="ScriptGuid">{62E506A8-2AC0-4DAB-BEED-9DCE2289018E}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- RemoteEvent

local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")
local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))

local CommonConstant = require(CommonModule:WaitForChild("CommonConstant"))
local MaxInventorySlotCount = CommonConstant.MaxInventorySlotCount

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType
local StatusType = CommonEnum.StatusType
local ToolType = CommonEnum.ToolType
local ArmorType = CommonEnum.ArmorType

local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local CommonGameDataManager = require(CommonGameDataModule:WaitForChild("CommonGameDataManager"))

local Inventory = require(script:WaitForChild("Inventory"))

--[[
PlayerTable
	Player ...
	
	Player(UserId, InstanceAddress)
	
		ArmorSlot(StatusType.ArmorSlot)
			- HelmetSlot
			- ChestplateSlot
			- LeggingsSlot
			- BootsSlot
			
		WeaponSlot(StatusType.WeaponSlot)
			- WeaponSlot	- 

		Inventory(StatusType.Inventory)
			- ToolType.Armor
				...
				
			- ToolType.Weapon
				...
			
			- ToolType.Consumable
				...
				
		QuickSlot(StatusType.QuickSlot) -- 클라이언트 전용
			...
		
--]]

local CommonGlobalStorage = {
	IsClient = false,
	PlayerTable = {}
}


function CommonGlobalStorage:CreateEmptyStatistic()
	return {
		DirtyFlag = false,
		STR = 0,
		DEF = 0,
		Move = 0,
		AttackSpeed = 0,
		
		HP = 0,
		MP = 0,
		HIT = 0,
		Dodge = 0,
		Block = 0,
		Critical = 0,
		Sight = 0
	}
end

function CommonGlobalStorage:CreateEmptyData()
	local playerData = {
		[StatusType.Statistic] = self:CreateEmptyStatistic(),
		[StatusType.ArmorSlot] = {
			-- 그냥 명시적으로 표현
			[ArmorType.Helmet] = {Value = nil, ToolGameData = nil},
			[ArmorType.Chestplate] = {Value = nil, ToolGameData = nil},
			[ArmorType.Leggings] = {Value = nil, ToolGameData = nil},
			[ArmorType.Boots] = {Value = nil, ToolGameData = nil}
		},

		-- 그냥 명시적으로 표현
		[StatusType.WeaponSlot] = {Value = nil, ToolGameData = nil},
		[StatusType.Inventory] = Utility:DeepCopy(Inventory)
	}

	if self.IsClient then
		playerData[StatusType.QuickSlot] = {}
	end
	
	return playerData
end

function CommonGlobalStorage:SetClientMode()
	self.IsClient = true
end

function CommonGlobalStorage:CheckPlayer(playerId)
	if self.PlayerTable[playerId] then
		return true
	end
	return false
end

function CommonGlobalStorage:AddPlayer(player)
	if not player then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return false
	end
	
	local playerId = player.UserId
	if self:CheckPlayer(playerId) == true then
		Debug.Assert(false, "두번 추가하려고 합니다 반드시 확인해야합니다.")
		return false
	end
	
	player.Backpack.ChildAdded:Connect(function(tool)
		self:AddTool(playerId, tool)
	end)

	player.Backpack.ChildRemoved:Connect(function(tool)
		self:RemoveTool(playerId, tool)
	end)
	
	self.PlayerTable[playerId] = self:CreateEmptyData()
	return true
end

function CommonGlobalStorage:RemovePlayer(player)
	if not player then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return false
	end
	
	local playerId = player.UserId
	self.PlayerTable[playerId] = nil
	
	return true
end

function CommonGlobalStorage:ClearPlayer(player)
	if not player then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return false
	end

	local playerId = player.UserId
	
	if not self:CheckPlayer(playerId) then
		Debug.Assert(false, "플레이어 데이터가 존재하지 않습니다.")
		return false
	end

	self.PlayerTable[playerId] = self:CreateEmptyData()
	return true
end

function CommonGlobalStorage:AddTool(playerId, tool)
	if self:CheckPlayer(playerId) == false then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return false
	end
	
	if not self.PlayerTable[playerId][StatusType.Inventory]:AddTool(tool) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end

function CommonGlobalStorage:RemoveTool(playerId, tool)
	if self:CheckPlayer(playerId) == false then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return false
	end

	if not self.PlayerTable[playerId][StatusType.Inventory]:RemoveTool(tool) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end

function CommonGlobalStorage:GetToolGameData(tool)
	
	if not tool then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end
	
	local key = tool:FindFirstChild("Key")
	if not key then
		Debug.Assert(false, "Key 객체가 존재하지 않습니다. => " .. tostring(tool))
		return nil
	end
	
	key = key.Value
	
	local toolGameData = CommonGameDataManager[GameDataType.Tool]:Get(key)
	if not toolGameData then
		Debug.Assert(false, "ToolGameData가 존재하지 않습니다. [key] => " .. tostring(key))
		return nil
	end
	
	return toolGameData
end

function CommonGlobalStorage:GetPlayerStatistic(playerId)

	if self:CheckPlayer(playerId) == false then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return nil
	end

	--self:CheckAndCalculateStatistic(playerId)
	return self.PlayerTable[playerId][StatusType.Statistic]
end

function CommonGlobalStorage:UpdateRemovedToolGameData(playerId, toolGameData)
	if not toolGameData then
		return
	end
	
	for attribute, value in pairs(toolGameData) do
		self.PlayerTable[playerId][StatusType.Statistic][attribute] -= value
	end
end

function CommonGlobalStorage:UpdateAddedToolGameData(playerId, toolGameData)
	if not toolGameData then
		return
	end
	
	for attribute, value in pairs(toolGameData) do
		self.PlayerTable[playerId][StatusType.Statistic][attribute] += value
	end
end

-- Weapon은 명시적으로 장착하는 것이 없다. 그냥 들고 있으면 알아서 EquipSlot에 집어넣어야한다.
function CommonGlobalStorage:CheckAndEquipIfWeapon(playerId, weapon)
	
	if self.CheckPlayer(playerId) == false then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if not weapon then
		Debug.Assert(false, "비정상입니다.")
		return false
	end

	local toolGameData = self:GetToolGameData(weapon)
	if not toolGameData then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if toolGameData.ToolType ~= ToolType.Weapon then
		return false
	end

	self:UpdateRemovedToolGameData(self.PlayerTable[playerId][StatusType.WeaponSlot].ToolGameData)
	self:UpdateAddedToolGameData(toolGameData)
	
	self.PlayerTable[playerId][StatusType.WeaponSlot].Value = weapon
	self.PlayerTable[playerId][StatusType.WeaponSlot].ToolGameData = toolGameData
	return true
end

function CommonGlobalStorage:CheckAndGetArmorData(armor)
	if not armor then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end

	local toolGameData = self:GetToolGameData(armor)
	if not toolGameData then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end

	if toolGameData.ToolType ~= ToolType.Armor then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end

	local armorType = toolGameData.ArmorType
	if not ArmorType[armorType] then
		Debug.Assert(false, "비정상입니다. [ArmorType] => " .. tostring(armorType))
		return nil
	end
	
	return toolGameData, armorType
end

function CommonGlobalStorage:EquipArmor(playerId, armor)
	
	if self:CheckPlayer(playerId) == false then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	local toolGameData, armorType = self:CheckAndGetArmorData(armor)
	if not toolGameData then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	self:UpdateRemovedToolGameData(self.PlayerTable[playerId][StatusType.WeaponSlot].ToolGameData)
	self:UpdateAddedToolGameData(toolGameData)
	
	self.PlayerTable[playerId][StatusType.ArmorSlot][armorType].Value = armor
	self.PlayerTable[playerId][StatusType.ArmorSlot][armorType].ToolGameData = toolGameData
	
	return true
end


CommonGlobalStorage.__index = Utility.Inheritable__index
CommonGlobalStorage.__newindex = Utility.Inheritable__newindex

return CommonGlobalStorage




-- 한번에 장착을 위한 기능들 --
--[[
function CommonGlobalStorage:GetAllToolGameData(playerId)

	if self:CheckPlayer(playerId) == false then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return false
	end

	local allToolData = {}
	local toolGameData = self.PlayerTable[playerId][StatusType.WeaponSlot].ToolGameData
	if toolGameData then
		table.insert(allToolData, toolGameData)
	end

	local allArmorSlots = self.PlayerTable[playerId][StatusType.ArmorSlot]

	for _, slot in pairs(allArmorSlots) do
		toolGameData = slot.ToolGameData
		if toolGameData then
			table.insert(allToolData, toolGameData)
		end
	end

	return allToolData
end

function CommonGlobalStorage:CheckStatisticDirtyFlag(playerId)
	return self.PlayerTable[playerId][StatusType.Statistic].DirtyFlag
end

function CommonGlobalStorage:CheckAndCalculateStatistic(playerId)
	if self:CheckPlayer(playerId) == false then
		Debug.Assert(false, "플레이어가 존재하지 않습니다.")
		return
	end

	if self:CheckStatisticDirtyFlag(playerId) == false then
		return
	end

	local allToolGameData = self:GetAllToolGameData(playerId)
	
	self.PlayerTable[playerId][StatusType.Statistic] = self:CreateEmptyStatistic()
	for _, toolGameData in pairs(allToolGameData) do

		for attribute, value in pairs(toolGameData) do
			self.PlayerTable[playerId][StatusType.Statistic][attribute] += value
		end
	end
end
--]]
-- 한번에 장착을 위한 기능들 --]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208bc</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Inventory</string>
						<string name="ScriptGuid">{F60F41CC-B89E-4EDA-8B73-ADE0C50B1FFF}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))

local CommonConstant = require(CommonModule:WaitForChild("CommonConstant"))
local MaxInventorySlotCount = CommonConstant.MaxInventorySlotCount

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType
local ToolType = CommonEnum.ToolType

local Container = CommonModule:WaitForChild("Container")
local InventoryRaw = Utility.DeepCopy(require(Container:WaitForChild("TArray")))

local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local CommonGameDataManager = require(CommonGameDataModule:WaitForChild("CommonGameDataManager"))

InventoryRaw:Initialize(MaxInventorySlotCount)

local Inventory = Utility.DeepCopy(require(script.Parent:WaitForChild("SlotBase")))
Inventory.InventoryRaw = InventoryRaw
Inventory[ToolType.Armor] = Utility.DeepCopy(InventoryRaw)
Inventory[ToolType.Weapon] = Utility.DeepCopy(InventoryRaw)
Inventory[ToolType.Consumable] = Utility.DeepCopy(InventoryRaw)

function Inventory:GetSlots(toolType)
	if toolType == ToolType.All then
		return self.InventoryRaw.GetValue()
	end
	
	return self[toolType]:GetValueToIndexTable()
end

function Inventory:AddTool(tool)
	local toolGameData = self:GetToolGameData(tool)
	if not toolGameData then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if not self.InventoryRaw:Push(tool) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if not self[toolGameData.ToolType]:Push(tool) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end

function Inventory:RemoveTool(tool)
	local toolGameData = self:GetToolGameData(tool)
	if not toolGameData then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if not self.InventoryRaw:PopByValue(tool) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end

	if not self[toolGameData.ToolType]:PopByValue(tool) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end


return Inventory
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208bd</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="10">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SlotBase</string>
						<string name="ScriptGuid">{348E9A9F-3571-430A-ACF1-9C5E33872A8F}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))

local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local GameDataType = CommonEnum.GameDataType

local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local CommonGameDataManager = require(CommonGameDataModule:WaitForChild("CommonGameDataManager"))

local SlotBase = {}

function SlotBase:GetToolGameData(tool)
	
	if not tool then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end

	local key = tool:FindFirstChild("Key")
	if not key then
		Debug.Assert(false, "Key 객체가 존재하지 않습니다. => " .. tostring(tool))
		return nil
	end

	key = key.Value
	local toolGameData = CommonGameDataManager[GameDataType.Tool]:Get(key)
	if not toolGameData then
		Debug.Assert(false, "ToolGameData가 존재하지 않습니다. [key] => " .. tostring(key))
		return nil
	end

	return toolGameData
end


return SlotBase
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208be</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="11">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Container</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208bf</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="12">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TArray</string>
						<string name="ScriptGuid">{8E0D5952-290C-4B0F-A3B4-6B5D74DC3879}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))
local CommonConstant = require(CommonModule:WaitForChild("CommonConstant"))
local UndefinedElementValue = CommonConstant.UndefinedElementValue

local Container = CommonModule:WaitForChild("Container")
local TContainerBase = Utility.DeepCopy(require(Container:WaitForChild("TContainerBase")))

local TArray = TContainerBase

function TArray:Initialize(maxCount)
	self:InitializeRaw(maxCount)
	
	if maxCount <= 0  then
		Debug.Assert(false, "배열 크기가 비정상입니다.")
		return false
	end
	for index = 1, maxCount do
		self.Value[index] = UndefinedElementValue
	end
	
	self.ValueToIndexTable = {}
	return true
end

function TArray:GetValue()
	return self.Value
end

function TArray:GetValueToIndexTable()
	return self.ValueToIndexTable
end

function TArray:IsEmptyIndex(index)
	return (self.Value[index] == UndefinedElementValue)
end

function TArray:IsFull()
	return self.CurrentCount >= self.MaxCount
end

function TArray:CheckIndex(index)
	if not self:CheckIndexRaw(index) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	if index > self.MaxCount then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end

function TArray:SetRaw(index, object)
	local isEmptyIndex = self:IsEmptyIndex(index)
	if object then
		if isEmptyIndex then
			self.CurrentCount += 1
		end
	else -- if not object then
		object = UndefinedElementValue
		if not isEmptyIndex then
			self.CurrentCount -= 1
		end
	end
	
	if not isEmptyIndex then
		self.ValueToIndexTable[self:GetRaw(index)] = nil
	end

	self.ValueToIndexTable[object] = index
	self.Value[index] = object
end

function TArray:Set(index, object)
	if not self:CheckIndex(index) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	self:SetRaw(index, object)
	return true
end

function TArray:GetRaw(index)
	return self.Value[index]
end

function TArray:Get(index)
	if not self:CheckIndex(index) then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end
	
	return self:GetRaw(index)
end

function TArray:Push(object)
	if self:IsFull() then
		Debug.Assert("비어 있는 공간이 없습니다.")
		return false
	end
	
	if not object then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
		
	local maxCount = self.MaxCount
	for index = 1, maxCount do
		if self:IsEmptyIndex(index) then
			self:SetRaw(index, object)
			return true
		end
	end
	
	Debug.Assert(false, "버그입니다. 확인해야합니다.")
	return false
end

function TArray:PopByIndex(index)
	if not self:CheckIndex(index) then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end
	
	local object = self:GetRaw(index)
	self:SetRaw(index, nil)
	
	return object
end

function TArray:GetIndex(value)
	if not value then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end
	
	return self.ValueToIndexTable[value]
end

function TArray:PopByValue(value)
	local targetIndex = self:GetIndex(value)
	if not targetIndex then
		Debug.Assert(false, "값이 존재하지 않습니다.")
		return nil
	end
	
	local result = self:PopByIndex(targetIndex)
	if not result then
		Debug.Assert(false, "인덱스 매핑에 버그가 있습니다.")
		return nil
	end
	
	return result
end

return TArray
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208c0</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="13">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TContainerBase</string>
						<string name="ScriptGuid">{1FBC55C2-8CD2-485A-BAD2-244E1B0E408F}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")
local Debug = require(CommonModule:WaitForChild("Debug"))
local CommonConstant = require(CommonModule:WaitForChild("CommonConstant"))
local UndefinedElementValue = CommonConstant.UndefinedElementValue

local TContainerBase = {
	Value = {
	
	}
}

function TContainerBase:InitializeRaw(maxCount)
	self.CurrentCount = 0	
	self.MaxCount = maxCount
end

function TContainerBase:IsEmpty()
	return (self.CurrentCount == 0)
end

function TContainerBase:CheckIndexRaw(index)
	if not index then
		Debug.Assert(false, "비정상입니다.")
		return false	
	end

	local typeString = type(index)
	if typeString ~= "number" then
		Debug.Assert(false, "비정상입니다.")
		return false	
	end
	
	if index <= 0 then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
	--[[
	local targetLimit = 0

	if self.MaxCount then
		targetLimit = self.MaxCount
	else
		targetLimit = self.CurrentCount
	end
	
	return (index <= targetLimit)
	--]]
end

return TContainerBase
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208c1</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="14">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TList</string>
						<string name="ScriptGuid">{04A86199-2611-406E-946A-D5ABEBE62298}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")

local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))
local CommonConstant = require(CommonModule:WaitForChild("CommonConstant"))
local UndefinedElementValue = CommonConstant.UndefinedElementValue

local Container = CommonModule:WaitForChild("Container")
local TContainerBase = Utility.DeepCopy(require(Container:WaitForChild("TContainerBase")))

local TList = TContainerBase

function TList:Initialize(maxCount)
	self:InitializeRaw(maxCount)
	return true
end

function TList:IsFull()
	if self.MaxCount then
		return self.CurrentCount >= self.MaxCount
	else -- if not self.MaxCount then
		return false		
	end
end

function TList:CheckIndex(index)
	if not self:CheckIndexRaw(index) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end

	if index > self.CurrentCount then
		Debug.Assert(false, "비정상입니다.")
		return false
	end

	return true
end

function TList:SetRaw(index, object)
	if not object  then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	self.Value[index] = object
end

function TList:Set(index, object)
	if not self:CheckIndex(index) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end

	if not self:SetRaw(index, object) then
		Debug.Assert(false, "비정상입니다.")
		return false
	end
	
	return true
end

function TList:GetRaw(index)
	return self.Value[index]
end

function TList:Get(index)
	if not self:CheckIndex(index) then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end

	return self:GetRaw(index)
end

function TList:Push(object)
	if not object then
		Debug.Assert(false, "비정상입니다.")
		return false	
	end

	if self:IsFull() then
		Debug.Assert(false, "더 이상 추가할 수 없습니다.")
		return false	
	end

	self.CurrentCount += 1
	table.insert(self.Value, object)
	return true
end

function TList:Pop(index)
	if not self:CheckIndex(index) then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end

	local object = self:GetRaw(index)
	table.remove(self.Value, index)
	self.CurrentCount -= 1
	
	return object
end

function TList:PopBack()
	if self:IsEmpty() then
		Debug.Assert(false, "비정상입니다.")
		return nil
	end
	
	local index = self.CurrentCount
	local object = self:GetRaw(index)
	table.remove(self.Value, index)
	self.CurrentCount -= 1

	return object
end

return TList
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208c2</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="15">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Debug</string>
					<string name="ScriptGuid">{C57C7462-5C3E-45E1-B5E5-18BF9C51618C}</string>
					<ProtectedString name="Source"><![CDATA[local Debug = {}

Debug.__index = function(table, key)
	local metatable = getmetatable(table)
	return metatable[key]
end

--local RedColor = Color3.new(255,0,0)
function Debug.Assert(expression, message)
	if not expression then
		if type(message) ~= "string" then
			message = tostring(message)
		end
		
		warn("Assert => " .. message .. "\nCallStack => " .. tostring(debug.traceback()))
		--printWithColor(RedColor, true, output)
	end
end

function Debug.Log(message)
	if type(message) ~= "string" then
		message = tostring(message)
	end
	warn("Log => " .. message .. "\nCallStack => " .. tostring(debug.traceback()))
end

function Debug.Print(message)
	if type(message) ~= "string" then
		message = tostring(message)
	end
	warn("Print => " .. message)
end

return Debug
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208c3</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="16">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Utility</string>
					<string name="ScriptGuid">{F140343E-936D-4351-BBC1-24B97616CB05}</string>
					<ProtectedString name="Source"><![CDATA[local Inheritable__index = function(table, key)
	local metatable = getmetatable(table)
	return metatable[key]
end

local Inheritable__newindex = function(table, key, value)
	local metatable = getmetatable(table)
	
	-- 부모 클래스도 없으면 그냥 본인 테이블에 넣는 것으로 정했다.
	local rv = metatable[key]
	if not rv then
		rawset(table, key, value)
	else
		metatable[key] = value
	end
end


function Immutable__newindex() end

local Utility = {
	Inheritable__index = Inheritable__index,
	Inheritable__newindex = Inheritable__newindex,
	Immutable__newindex = Immutable__newindex,
	EmptyFunction = Immutable__newindex
}

Utility.__index = Inheritable__index
Utility.__newindex = Immutable__newindex


function Utility.DeepCopy(original)

	local originalType = type(original)
	local copy = {}

	if originalType == 'table' then

		for key, value in next, original, nil do
			copy[Utility.DeepCopy(key)] = Utility.DeepCopy(value)
		end
		setmetatable(copy, Utility.DeepCopy(getmetatable(original)))

	else -- number, string, boolean, etc
		copy = original
	end

	return copy
end

function Utility.DeepCopyWithoutMetatable(original)

	local originalType = type(original)
	local copy = {}

	if originalType == 'table' then

		for key, value in next, original, nil do
			copy[Utility.DeepCopy(key)] = Utility.DeepCopy(value)
		end
		setmetatable(copy, getmetatable(original))

	else -- number, string, boolean, etc
		copy = original
	end

	return copy
end


return Utility
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208c4</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="17">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CommonModuleFacade</string>
				<string name="ScriptGuid">{2CA6DC41-DCC0-478C-ACAF-7F85A02B3D29}</string>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommonModule = ReplicatedStorage:WaitForChild("CommonModule")
local CommonConstant = require(CommonModule:WaitForChild("CommonConstant"))
local CommonEnum = require(CommonModule:WaitForChild("CommonEnum"))
local Debug = require(CommonModule:WaitForChild("Debug"))
local Utility = require(CommonModule:WaitForChild("Utility"))

local Container = CommonModule:WaitForChild("Container")
local TArray = require(Container:WaitForChild("TArray"))
local TList = require(Container:WaitForChild("TList"))

local CommonGameDataModule = CommonModule:WaitForChild("CommonGameDataModule")
local CommonGameDataManager = require(CommonGameDataModule:WaitForChild("CommonGameDataManager"))
--local GameDataBase = require(CommonGameDataModule:WaitForChild("GameDataBase"))

local CommonGlobalStorage = require(CommonModule:WaitForChild("CommonGlobalStorage"))


local CommonModuleFacade = {
	CommonModule = CommonModule,
	CommonConstant = CommonConstant,
	CommonEnum = CommonEnum,
	CommonGameDataModule = CommonGameDataModule,
	CommonGameDataManager = CommonGameDataManager,
	--GameDataBase = GameDataBase,
	CommonGlobalStorage = CommonGlobalStorage,
	TArray = TArray,
	TList = TList,
	Utility = Utility,
	Debug = Debug
}

CommonModuleFacade.__index = CommonModuleFacade.Utility.Inheritable__index
CommonModuleFacade.__newindex = CommonModuleFacade.Utility.Inheritable__newindex

return CommonModuleFacade
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4be746d508fb104102f2ac73000208c5</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX4E5844D775344F3A846F91889424B0D5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002085e</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBXE6A446180785425F9196AD126A7A39F3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002085f</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX8E679909770E40D0B1E9B11FF07B9A94">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020884</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBXDADBE8D8412D4FD0BD969DFA1A252DB7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac7300020887</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX46D45EDF071A43C3AEA09A5DF9C2C2A5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002c7e0</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBX9608E493F36F4E009921740D2F2D07B1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002c800</UniqueId>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBX78878E96C7B1454282DF9E0C4FAFFD32">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4be746d508fb104102f2ac730002ca45</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>